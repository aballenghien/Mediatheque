#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.4 (svn snaphsot 9308) [????]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/

#ifdef __cplusplus
}
#endif
#include "mediatheque.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.c) is included for _all_ modes of
  compilation (-boost, -no_check, ... -all_check).
*/

/*
  Byte swapping function
*/
void copy_swap_16(const uint16_t *src, uint16_t *dest, int count){
  while (count--) {
    *dest++ = (*src << 8) | (*src >> 8);
    src++;
  }
}


/*
  The wrapper for `malloc' (generated C code is supposed to use
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (malloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (calloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `realloc' (generated C code is supposed to use
  only `se_realloc' instead of direct `realloc').
*/
void* se_realloc(void* src, size_t size) {
  void *result = realloc(src, size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (realloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/* ---------------------------------------------------------------------- */

void se_die (int code) {
  handle(SE_HANDLE_DIE_WITH_CODE, &code);
  exit(code);
}

/*
    Runtime hooks
 */

static se_runtime_handler_t** handlers = NULL;
int handlers_count=0;

void register_handler(se_runtime_handler_t*handler) {
  int new_count = handlers_count + 1;
  handlers = (se_runtime_handler_t**)se_realloc(handlers, (new_count) * sizeof(void*));
  handlers[handlers_count] = handler;
  handlers_count = new_count;
}

void _handle(se_handler_action_t action, void*data) {
  int i;
  for (i = 0; i < handlers_count; i++) {
    handlers[i](action, data);
    /* *** Check type of this array. Function pointer may have different size from data pointer. (PH 17/07/08) */
  }
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
/* macro read is used of read_stdin */

void io_copy (char*source, char*target) {
  /* We use the low-level descriptor functions rather than stream-oriented functions.
   * This allows us to copy the file's permissions. */

  int src;
  int tgt;
  struct stat info;
  static char *buffer = NULL;
  static int bufsize = 0;
  int read_count, write_count, written;

  src=open (source, O_RDONLY);
  if (fstat (src, &info))
    return; /* Ooops */
  if (bufsize < info.st_blksize)
    buffer=se_realloc (buffer, info.st_blksize);
  tgt=creat (target, info.st_mode);
  do {
    read_count = read (src, buffer, info.st_blksize);
    write_count = 0; written = 0;
    while  ((write_count < read_count) && (written >= 0))
      {
	written = write (tgt, buffer + write_count, read_count - write_count);
	write_count += written;
      }
  } while ((read_count > 0) && (written >= 0));
  close (src);
  close (tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  struct stat info1, info2;
  if (stat(path1, &info1))
    return 0; /* oops */
  if (stat(path2, &info2))
    return 0; /* oops */
  return (info1.st_dev == info2.st_dev) && (info1.st_ino == info2.st_ino);
}

#else
#define IO_COPY_BUFSIZE 4096

int read_stdin(EIF_CHARACTER *buffer, int size) {
  int c;
  c = getc(stdin);
  if (c==EOF)
    return 0;
  *buffer = (EIF_CHARACTER)c;
  return 1;
}

void io_copy(char*source, char*target) {
  static char *buffer = NULL;
  int read_count;
  FILE*src=fopen(source, "rb");
  FILE*tgt=fopen(target, "wb");

  if(!buffer)
    buffer = (char*)se_malloc(IO_COPY_BUFSIZE);

  while ((read_count = fread(buffer, 1, IO_COPY_BUFSIZE, src)), read_count) {
    fwrite(buffer, 1, read_count, tgt);
  }
  fclose(src);
  fclose(tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  /* default implementation returns true only if the paths are the same */
  return !strcmp(path1, path2);
}
#endif

int io_file_exists(char*source) {
  FILE*src=fopen(source, "rb");
  if (src!=NULL) {
    fclose(src);
    return 1;
  }
  else {
    return (errno != ENOENT);
  }
}

void se_prinT185(FILE* file,T185*o){
fprintf(file,"NATIVE_ARRAY[STRING]");
fprintf(file,"#%p",(void*)*o);
}/*--*/

void se_prinT184(FILE* file,T184*o){
fprintf(file,"NATIVE_ARRAY[UTILISATEUR]");
fprintf(file,"#%p",(void*)*o);
}/*--*/

void se_prinT182(FILE* file,T182*o){
fprintf(file,"NATIVE_ARRAY[ACTEUR]");
fprintf(file,"#%p",(void*)*o);
}/*--*/

void se_prinT181(FILE* file,T181*o){
fprintf(file,"NATIVE_ARRAY[AUTEUR]");
fprintf(file,"#%p",(void*)*o);
}/*--*/

void se_prinT180(FILE* file,T180*o){
fprintf(file,"NATIVE_ARRAY[REALISATEUR]");
fprintf(file,"#%p",(void*)*o);
}/*--*/

void se_prinT183(FILE* file,T183*o){
fprintf(file,"NATIVE_ARRAY[LIVRE]");
fprintf(file,"#%p",(void*)*o);
}/*--*/

void se_prinT179(FILE* file,T179*o){
fprintf(file,"NATIVE_ARRAY[DVD]");
fprintf(file,"#%p",(void*)*o);
}/*--*/

void se_prinT178(FILE* file,T178*o){
fprintf(file,"NATIVE_ARRAY[MEDIA]");
fprintf(file,"#%p",(void*)*o);
}/*--*/
T48 M48={48,(void*)0,0,(void*)0,0};

void se_prinT48(FILE* file,T48**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"STD_OUTPUT");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"filter = ");
se_prinT0(file,(T0**)(&((*o)->_filter)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer_position = ");
se_prinT2(file,(&((*o)->_buffer_position)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer = ");
se_prinT9(file,(&((*o)->_buffer)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t]");
}/*--*/
T49 M49={49,(void*)0,0,0,(void*)0,0,0,0,0,0};

void se_prinT49(FILE* file,T49**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"STD_INPUT");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"filter = ");
se_prinT0(file,(T0**)(&((*o)->_filter)));
fprintf(file,"\n\t  ");
fprintf(file,"end_of_input = ");
se_prinT6(file,(&((*o)->_end_of_input)));
fprintf(file,"\n\t  ");
fprintf(file,"filtered_last_character = ");
se_prinT3(file,(&((*o)->_filtered_last_character)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer = ");
se_prinT9(file,(&((*o)->_buffer)));
fprintf(file,"\n\t  ");
fprintf(file,"end_reached = ");
se_prinT6(file,(&((*o)->_end_reached)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer_size = ");
se_prinT2(file,(&((*o)->_buffer_size)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer_position = ");
se_prinT2(file,(&((*o)->_buffer_position)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"unread_character_flag = ");
se_prinT6(file,(&((*o)->_unread_character_flag)));
fprintf(file,"\n\t]");
}/*--*/
T177 M177={177,(void*)0,0,0,0};

void se_prinT177(FILE* file,T177**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"ARRAY[STRING]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT185(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t  ");
fprintf(file,"lower = ");
se_prinT2(file,(&((*o)->_lower)));
fprintf(file,"\n\t]");
}/*--*/
T64 M64={64,(void*)0,(void*)0,0,0,(void*)0,(void*)0,0,0,0,0};

void se_prinT64(FILE* file,T64**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"TEXT_FILE_READ");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"filter = ");
se_prinT0(file,(T0**)(&((*o)->_filter)));
fprintf(file,"\n\t  ");
fprintf(file,"path = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_path)));
fprintf(file,"\n\t  ");
fprintf(file,"end_of_input = ");
se_prinT6(file,(&((*o)->_end_of_input)));
fprintf(file,"\n\t  ");
fprintf(file,"filtered_last_character = ");
se_prinT3(file,(&((*o)->_filtered_last_character)));
fprintf(file,"\n\t  ");
fprintf(file,"input_stream = ");
se_prinT8(file,(&((*o)->_input_stream)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer = ");
se_prinT9(file,(&((*o)->_buffer)));
fprintf(file,"\n\t  ");
fprintf(file,"end_reached = ");
se_prinT6(file,(&((*o)->_end_reached)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer_size = ");
se_prinT2(file,(&((*o)->_buffer_size)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer_position = ");
se_prinT2(file,(&((*o)->_buffer_position)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t]");
}/*--*/
T176 M176={176,(void*)0,0,0,0};

void se_prinT176(FILE* file,T176**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"ARRAY[UTILISATEUR]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT184(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t  ");
fprintf(file,"lower = ");
se_prinT2(file,(&((*o)->_lower)));
fprintf(file,"\n\t]");
}/*--*/
T60 M60={60,(void*)0,(void*)0,(void*)0};

void se_prinT60(FILE* file,T60**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"ACTEUR");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"nom = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_nom)));
fprintf(file,"\n\t  ");
fprintf(file,"prenom = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_prenom)));
fprintf(file,"\n\t  ");
fprintf(file,"lst_films = ");
se_prinT0(file,(T0**)(&((*o)->_lst_films)));
fprintf(file,"\n\t]");
}/*--*/
T174 M174={174,(void*)0,0,0,0};

void se_prinT174(FILE* file,T174**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"ARRAY[ACTEUR]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT182(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t  ");
fprintf(file,"lower = ");
se_prinT2(file,(&((*o)->_lower)));
fprintf(file,"\n\t]");
}/*--*/
T56 M56={56,(void*)0,(void*)0,(void*)0};

void se_prinT56(FILE* file,T56**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"AUTEUR");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"nom = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_nom)));
fprintf(file,"\n\t  ");
fprintf(file,"prenom = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_prenom)));
fprintf(file,"\n\t  ");
fprintf(file,"lst_livres = ");
se_prinT0(file,(T0**)(&((*o)->_lst_livres)));
fprintf(file,"\n\t]");
}/*--*/
T173 M173={173,(void*)0,0,0,0};

void se_prinT173(FILE* file,T173**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"ARRAY[AUTEUR]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT181(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t  ");
fprintf(file,"lower = ");
se_prinT2(file,(&((*o)->_lower)));
fprintf(file,"\n\t]");
}/*--*/
T59 M59={59,(void*)0,(void*)0,(void*)0};

void se_prinT59(FILE* file,T59**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"REALISATEUR");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"nom = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_nom)));
fprintf(file,"\n\t  ");
fprintf(file,"prenom = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_prenom)));
fprintf(file,"\n\t  ");
fprintf(file,"lst_films = ");
se_prinT0(file,(T0**)(&((*o)->_lst_films)));
fprintf(file,"\n\t]");
}/*--*/
T172 M172={172,(void*)0,0,0,0};

void se_prinT172(FILE* file,T172**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"ARRAY[REALISATEUR]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT180(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t  ");
fprintf(file,"lower = ");
se_prinT2(file,(&((*o)->_lower)));
fprintf(file,"\n\t]");
}/*--*/
T50 M50={50,(void*)0,0,(void*)0};

void se_prinT50(FILE* file,T50**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"LIVRE");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"titre = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_titre)));
fprintf(file,"\n\t  ");
fprintf(file,"nombre_exemplaires = ");
se_prinT2(file,(&((*o)->_nombre_exemplaires)));
fprintf(file,"\n\t  ");
fprintf(file,"auteur = ");
se_prinT0(file,(T0**)(&((*o)->_auteur)));
fprintf(file,"\n\t]");
}/*--*/
T175 M175={175,(void*)0,0,0,0};

void se_prinT175(FILE* file,T175**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"ARRAY[LIVRE]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT183(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t  ");
fprintf(file,"lower = ");
se_prinT2(file,(&((*o)->_lower)));
fprintf(file,"\n\t]");
}/*--*/
T58 M58={58,(void*)0,0,0,(void*)0,(void*)0,(void*)0};

void se_prinT58(FILE* file,T58**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"DVD");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"titre = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_titre)));
fprintf(file,"\n\t  ");
fprintf(file,"nombre_exemplaires = ");
se_prinT2(file,(&((*o)->_nombre_exemplaires)));
fprintf(file,"\n\t  ");
fprintf(file,"annee = ");
se_prinT2(file,(&((*o)->_annee)));
fprintf(file,"\n\t  ");
fprintf(file,"type = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_type)));
fprintf(file,"\n\t  ");
fprintf(file,"lst_acteurs = ");
se_prinT0(file,(T0**)(&((*o)->_lst_acteurs)));
fprintf(file,"\n\t  ");
fprintf(file,"lst_realisateurs = ");
se_prinT0(file,(T0**)(&((*o)->_lst_realisateurs)));
fprintf(file,"\n\t]");
}/*--*/
T171 M171={171,(void*)0,0,0,0};

void se_prinT171(FILE* file,T171**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"ARRAY[DVD]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT179(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t  ");
fprintf(file,"lower = ");
se_prinT2(file,(&((*o)->_lower)));
fprintf(file,"\n\t]");
}/*--*/
T170 M170={170,(void*)0,0,0,0};

void se_prinT170(FILE* file,T170**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"ARRAY[MEDIA]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT178(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t  ");
fprintf(file,"lower = ");
se_prinT2(file,(&((*o)->_lower)));
fprintf(file,"\n\t]");
}/*--*/
T61 M61={61,(void*)0,(void*)0,(void*)0,0};

void se_prinT61(FILE* file,T61**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"UTILISATEUR");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"nom = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_nom)));
fprintf(file,"\n\t  ");
fprintf(file,"prenom = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_prenom)));
fprintf(file,"\n\t  ");
fprintf(file,"identifiant = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_identifiant)));
fprintf(file,"\n\t  ");
fprintf(file,"admin = ");
se_prinT6(file,(&((*o)->_admin)));
fprintf(file,"\n\t]");
}/*--*/
T41 M41={41,(void*)0,(void*)0,(void*)0};

void se_prinT41(FILE* file,T41**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"STD_INPUT_OUTPUT");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"filter = ");
se_prinT0(file,(T0**)(&((*o)->_filter)));
fprintf(file,"\n\t  ");
fprintf(file,"output_filter = ");
se_prinT0(file,(T0**)(&((*o)->_output_filter)));
fprintf(file,"\n\t  ");
fprintf(file,"input_filter = ");
se_prinT0(file,(T0**)(&((*o)->_input_filter)));
fprintf(file,"\n\t]");
}/*--*/
T25 M25={25,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};

void se_prinT25(FILE* file,T25**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"MEDIATHEQUE");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"lst_users = ");
se_prinT0(file,(T0**)(&((*o)->_lst_users)));
fprintf(file,"\n\t  ");
fprintf(file,"lst_acteurs = ");
se_prinT0(file,(T0**)(&((*o)->_lst_acteurs)));
fprintf(file,"\n\t  ");
fprintf(file,"lst_realisateurs = ");
se_prinT0(file,(T0**)(&((*o)->_lst_realisateurs)));
fprintf(file,"\n\t  ");
fprintf(file,"lst_auteurs = ");
se_prinT0(file,(T0**)(&((*o)->_lst_auteurs)));
fprintf(file,"\n\t  ");
fprintf(file,"lst_livres = ");
se_prinT0(file,(T0**)(&((*o)->_lst_livres)));
fprintf(file,"\n\t  ");
fprintf(file,"lst_dvd = ");
se_prinT0(file,(T0**)(&((*o)->_lst_dvd)));
fprintf(file,"\n\t  ");
fprintf(file,"lst_media_choisis = ");
se_prinT0(file,(T0**)(&((*o)->_lst_media_choisis)));
fprintf(file,"\n\t  ");
fprintf(file,"utilisateur_connecte = ");
se_prinT0(file,(T0**)(&((*o)->_utilisateur_connecte)));
fprintf(file,"\n\t]");
}/*--*/

void se_prinT9(FILE* file,T9*o){
fprintf(file,"NATIVE_ARRAY[CHARACTER]");
fprintf(file,"#%p",(void*)*o);
}/*--*/
T7 M7={7,(void*)0,0,0};
/*Aliased storage area or unicode storage.*/
char*s25_0="";
char*s25_10="\n";
char*s25_1502332569="Veuillez choisir";
char*s62_117797837="0123456789";
char*s25_47="/";
char*s25_62=">";
char*s25_78="N";
char*s25_79="O";
char*s61_125="\175""";
char*s59_204=" ,";
char*s25_234255023="Identifiant non reconnu";
char*s25_1987806774="6. Je connais l\'ann\303""\251""e de la parution du DVD";
char*s25_498422136="1. Je sais quel type de m\303""\251""dia je cherche";
char*s61_56097703="UTILISATEUR : \173""nom : ";
char*s25_846833530="Donnez une ann\303""\251""e sur quatres chiffres";
char*s25_13127="USER";
char*s25_13130="Nom<";
char*s25_582057685="4. Je connais un auteur";
char*s25_1288899863="Aucune action ne correspond \303""\240"" ce choix !";
char*s25_997=" ! ";
char*s25_262181241="medias.txt";
char*s25_968328357="REALISATEUR";
char*s25_56485="Admin";
char*s61_546849747=", prenom : ";
char*s25_1793755989="*** Ajouter un nouvel utilisateur ***";
char*s25_1315952470="Affichage des DVD : ";
char*s25_1186886054="Donnez le nom et/ou le prenom du r\303""\251""alisateur (au format nom/prenom)";
char*s25_953418799="2. Je connais le titre";
char*s25_863614211="Donnez le titre ou une partie du titre:";
char*s25_384844997="1. Consulter la liste des m\303""\251""dias";
char*s25_69196="Titre";
char*s25_1009749943="Donnez le nom et/ou le prenom de l\'auteur (au format nom/prenom)";
char*s25_321084001="Vous n\'\303""\252""tes pas autoris\303""\251"" \303""\240"" ex\303""\251""cuter cette action.";
char*s25_784119050="Affichage des utilisateurs : ";
char*s25_14186="Type";
char*s61_445180577=", identifiant : ";
char*s25_1224770635="> ; Identifiant<";
char*s50_7407872="LIVRE : ";
char*s25_179980337="Bienvenue ";
char*s25_1184979933="*** CONNEXION ***";
char*s25_1033979069="Retour au menu principal \? O/N (N = d\303""\251""connexion)";
char*s25_1046453349="Realisateur";
char*s25_2198="DVD";
char*s25_1071906274="Pr\303""\251""nom de l\'utilisateur \? ";
char*s25_57731="Annee";
char*s25_1395793447="utilisateurs.txt";
char*s25_1032527758="Veuillez entrer votre identifiant : ";
char*s25_2473="OUI";
char*s25_2029623371="En quel ann\303""\251""e est sortie le DVD \?";
char*s25_2614="Nom";
char*s25_1104285512="Le format est nom/prenom";
char*s25_64246="Livre";
char*s25_306365602="MEDIACHOISIS";
char*s25_1276852086=" m\303""\251""dias correspondants \303""\240"" votre recherche :";
char*s25_864605964="Affichage des realisateurs : ";
char*s25_894124683="5. Je connais un r\303""\251""alisateur";
char*s25_461537271="6. Ajouter un utilisateur";
char*s56_1652635404="AUTEUR : \173""nom : ";
char*s25_1702476960=" ; Admin<OUI>";
char*s25_111059567="5. Modifier les informations d\'un utilisateur";
char*s25_958470591="Identifiant";
char*s59_525852488=", lst_films : ";
char*s25_1618319333="3. Je connais un acteur";
char*s25_616862766="Veuillez choisir un chiffre entre 1 et 7";
char*s25_9334699="3. G\303""\251""rer mes r\303""\251""servations / mes emprunts";
char*s25_1303486749="Affichage des livres : ";
char*s25_695202130="> ; Prenom<";
char*s25_62141258="Vous avez utilisez vos 3 essais. Votre compte a \303""\251""t\303""\251"" bloqu\303""\251"", veuillez contacter un administrateur de la m\303""\251""diath\303""\250""que pour pouvoir vous reconnecter";
char*s25_329871="Nombre";
char*s25_59254="LIVRE";
char*s25_615602212="Choisissez un crit\303""\250""re de recherche : ";
char*s25_1492187474="Donnez le nom et/ou le prenom de l\'acteur (au format nom/prenom)";
char*s25_925698945="4. Consulter la liste des utilisateurs";
char*s25_268982="AUTEUR";
char*s25_1967032801="Que souhaitez vous faire \?";
char*s56_525349142=", lst_livres :";
char*s25_2089597834="Affichage des auteurs : ";
char*s25_1577219632="L\'utilisateur sera t\'il un administrateur \? (O/N)";
char*s25_293974="Auteur";
char*s25_328099401="7. Ajouter un m\303""\251""dia";
char*s25_337289="Prenom";
char*s59_109369943=", prenom :";
char*s58_275872="DVD : ";
char*s59_873484181="REALISATEUR : \173""nom : ";
char*s25_2096629084="Affichage des acteurs : ";
char*s25_1408959593="2. Rechercher un m\303""\251""dia";
char*s25_1726621843="Nous avons trouv\303""\251"" ";
char*s25_1332170574="En cours de d\303""\251""veloppement...";
char*s60_153233041="ACTEUR : \173""nom : ";
char*s25_1047631513="Identifiant de l\'utilisateur \? ";
char*s25_257732="ACTEUR";
char*s60_753822955=", lst_films :";
char*s25_1479481184="Nom de l\'utilisateur \? ";
char*s25_979195894="Vous recherchez : 1: Un DVD, 2: Un Livre \?";
char*s25_282724="Acteur";
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/no_check.c) is automatically included
  when `ace.no_check' is true (ie. all modes except -boost).
*/

int assertion_depth=1;

/*
   To print object into the trace-stack :
*/
void se_prinT0(FILE* file, T0** o) {
    if (*o == NULL) {
	fprintf(file,"Void");
    }
    else {
	fprintf(file,"#%p",(void*)*o);
    }
}

void se_prinT1(FILE* file, EIF_INTEGER_8* o) {
    fprintf(file,"%"PRId8,*o);
}

void se_prinT2(FILE* file, EIF_INTEGER* o) {
    fprintf(file,"%"PRId32,*o);
}

void se_prinT10(FILE* file, EIF_INTEGER_16* o) {
    fprintf(file,"%"PRId16,*o);
}

void se_prinT11(FILE* file,EIF_INTEGER_64* o) {
    fprintf(file,"%"PRId64,*o);
}

static void se_print_character(FILE* file, char c) {
    /* Produce a visible output of `c' using an Eiffelish notation.
     */
    if ((' ' <= c)&&(c <= '~')&&(c != '\'')&&(c != '\"')&&(c != '%')) {
	putc(c,file);
    }
    else {
	switch (c) {
	    case '\b': fprintf(file,"%%B"); break;
	    case '\f': fprintf(file,"%%F"); break;
	    case '\n': fprintf(file,"%%N"); break;
	    case '\r': fprintf(file,"%%R"); break;
	    case '\t': fprintf(file,"%%T"); break;
	    case '\0': fprintf(file,"%%U"); break;
	    case '\'': fprintf(file,"%%\'"); break;
	    case '\"': fprintf(file,"%%\""); break;
	    case '%':  fprintf(file,"%%%%"); break;
	    default:
		fprintf(file,"%%/%d/", (int) ((unsigned char) c));
	}
    }
}

void se_prinT3(FILE* file,EIF_CHARACTER* o) {
    putc('\'',file);
    se_print_character(file, *o);
    putc('\'',file);
}

void se_prinT4(FILE* file, EIF_REAL_32* o) {
    fprintf(file, "%.7e", ((real64_t)*o));
}

void se_prinT5(FILE* file, EIF_REAL_64* o) {
    fprintf(file, "%.16e", *o);
}

void se_prinT12(FILE* file, EIF_REAL_EXTENDED* o) {
    fprintf(file, "%.19Le", *o);
}

void se_prinT6(FILE* file, EIF_BOOLEAN* o) {
    if (*o) {
	fprintf(file,"True");
    }
    else {
	fprintf(file,"False");
    }
}

void se_prinT7(FILE* file, EIF_STRING* o) {
    if (*o == NULL) {
	fprintf(file,"Void");
    }
    else {
	T3* storage = (*o)->_storage;
	int count = (*o)->_count;
	int i = 0;
	putc('\"',file);
	while (i < count) {
	    se_print_character(file, storage[i++]);
	}
	putc('\"',file);
    }
}

void se_prinT8(FILE* file, EIF_POINTER* o) {
    if (*o == NULL) {
	fprintf(file,"NULL");
    }
    else {
	fprintf(file,"POINTER#%p",(void*)*o);
    }
}


/*
  The upper most context (SmartEiffel Dump stack Top) :
*/
se_dump_stack* se_dst=NULL;

int se_stack_size(se_dump_stack* ds) {
  int result = 0;
  while (ds != NULL) {
    ds = ds->caller;
    result ++;
  }
  return result;
}

void se_print_run_time_stack(void) {
  se_print_run_time_stack_in(SE_ERR);
}

void se_print_run_time_stack_in(FILE* file) {
  /* ANY.print_run_time_stack */
  se_dump_stack* origin;
  se_dump_stack* ds;
  se_dump_stack* ds2;
  int frame_count = 1;
  int rescue = 0;

  handle(SE_HANDLE_ENTER_PRINT_STACK, NULL);
  origin = se_dst;
  if (origin == NULL) {
    fprintf(file,"Empty stack.\n");
    return ;
  }
  else {
    while (origin->exception_origin != NULL) {
      origin = origin->exception_origin;
    }

    ds = origin;
    while (ds->caller != NULL) {
      ds = ds->caller;
      frame_count++;
    }
  }
  fprintf(file,"%d frames in current stack.\n",frame_count);
  fprintf(file,"=====  Bottom of run-time stack  =====\n");
  while (ds != NULL) {
    se_print_one_frame_in(file,ds);
    /* Next frame : */
    if (ds == origin) {
      ds = NULL;
    }
    else if (ds->exception_origin != NULL) {
      rescue = 1;
      ds = ds->exception_origin;
    }
    else {
      ds2 = se_dst;
      while (ds2->caller != ds) {
	ds2 = ds2->caller;
      }
      ds = ds2;
    }
    if (--frame_count) {
      if (!rescue) {
        fprintf(file,"======================================\n");
      }
      else {
        fprintf(file,"====   Rescue stack  =================\n");
      }
    }
  }
  fprintf(file,"=====   Top of run-time stack    =====\n");

  handle(SE_HANDLE_EXIT_PRINT_STACK, NULL);
}

int se_print_one_frame(se_dump_stack* ds) {
  return se_print_one_frame_in(SE_ERR, ds);
}

int se_print_one_frame_in(FILE* file, se_dump_stack* ds) {
  /* Return 1 for an ordinary frame (not a cecil frame or some dynamic
     dispatch extra frame). */
  se_frame_descriptor* fd = ds->fd;
  int i = 0;
  int local_count = 0;
  char* local_format;
  int expanded;
  int id;
  void** var;

  if (fd == NULL) {
    fprintf(file,"External CECIL call.\n");
    return 0;
  }
  fprintf(file,"%s\n",fd->name);
  if (ds->p == 0) return 0;
  local_format = fd->local_format;
  if (fd->use_current) {
    fprintf(file,"Current = ");
    i = 2;
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    (se_prinT[id])(file, ds->current);
    fprintf(file,"\n");
  }
  while (local_count < fd->local_count) {
    while (local_format[i] != '%') {
      fprintf(file,"%c",local_format[i]);
      i++;
    }
    i++;
    expanded = ((local_format[i++] == 'E')?1:0);
    fprintf(file," = ");
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    if (ds->locals == NULL) {
      fprintf(file,"<unavailable>");
    }
    else {
      var = (ds->locals)[local_count];
      if (expanded) {
        (se_prinT[id])(file, (void**)(var));
      }
      else if (*var == NULL) {
        fprintf(file,"Void");
      }
      else {
        (se_prinT[((T0*)(*var))->id])(file, (void**)(var));
      }
    }
    fprintf(file,"\n");
    local_count++;
  }
  fprintf(file,"line %d ",se_position2line(ds->p));
  fflush(file);
  fprintf(file,"column %d ",se_position2column(ds->p));
  fflush(file);
  fprintf(file,"file %s \n",p[se_position2path_id(ds->p)]);
  fflush(file);
  return 1;
}

int se_rci(se_dump_stack*caller,void*C) {
  /* Where `caller' is supposed to be reference type non Void Current
     object. This function return 1 if the class invariant must be
     checked for `C' before leaving the routine.
  */
  if (caller != NULL) {
    se_frame_descriptor* fd = caller->fd;
    if (fd == NULL) {
      /* As for example when coming via CECIL. */
      return 0;
    }
    else {
      if (fd->use_current) {
	if (fd->local_format[1] == 'R') {
	  if ((*((void**)caller->current)) == C) {
	    return 0;
	  }
	}
      }
    }
  }
  return 1;
}

void error0(char* m, char* vv) {
  /* When there is nothing more to do than to exit or to go back
     into the debugger.
  */
  static char*f="*** Error at Run Time ***: %s\n";

  fprintf(SE_ERR,f,m);
  if (vv!=NULL) fprintf(SE_ERR,f,vv);
#ifdef SE_EXCEPTIONS
  print_exception();
#endif
#ifdef SE_SEDB
  sedb_break(se_dst,0);
#else
  handle(SE_HANDLE_RUNTIME_ERROR, m);
  se_print_run_time_stack();
  fprintf(SE_ERR,f,m);
  if (vv!=NULL)
    fprintf(SE_ERR,f,vv);
  exit(EXIT_FAILURE);
#endif
}

void error1(char*m,se_position position) {
  /* When there is nothing more to do than to exit or to go back
     into the debugger.
  */
  int l = se_position2line(position);
  int c = se_position2column(position);
  int f = se_position2path_id(position);
  char* f1 = "Line : %d column %d in %s.\n";
  char* f2 = "*** Error at Run Time ***: %s\n";

  fprintf(SE_ERR,f1,l,c,p[f]);
  fprintf(SE_ERR,f2,m);
#ifdef SE_EXCEPTIONS
  print_exception();
#endif
#ifdef SE_SEDB
  sedb_break(se_dst,position);
#else
  handle(SE_HANDLE_RUNTIME_ERROR, m);
  se_print_run_time_stack();
  fprintf(SE_ERR,f1,l,c,p[f]);
  fprintf(SE_ERR,f2,m);
  exit(EXIT_FAILURE);
#endif
}

void se_print_string(FILE*stream, EIF_STRING s) {
  /* To print some Eiffel STRING. */
  if (s == NULL) {
    fprintf(stream,"Void");
  }
  else {
    int count = s->_count;
    EIF_CHARACTER* storage = s->_storage;
    int i = 0;
    fprintf(stream,"\"");
    while (count != 0) {
      fprintf(stream,"%c",storage[i]);
      i++;
      count--;
    }
    fprintf(stream,"\"");
  }
}

void se_print_bad_target(FILE*stream, int id, T0* o, int l, int c, int f) {
  /* Print Bad Target Type Error Message. */
  if (l != 0) {
    fprintf(stream,"Line : %d column %d in %s.\n",l,c,p[f]);
  }
  fprintf(stream,"*** Error at Run Time *** :\n");
  fprintf(stream,"   Target is not valid (not the good type).\n");
  fprintf(stream,"   Expected: ");
  se_print_string(stream,t[id]);
  fprintf(stream,", Actual: ");
  se_print_string(stream,t[o->id]);
  fprintf(stream,".\n");
}

void error2(T0*o, se_position position) {
  fprintf(SE_ERR,"Target Type ");
  se_print_string(SE_ERR,t[o->id]);
  fprintf(SE_ERR," is not valid.\n");
  error1("Bad target.",position);
}

T0* vc(T0* o, se_position position) {
  /*
    Void check for reference target.
  */
  if (o != NULL) {
    return o;
  }
  else {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Void_call_target);
#else
    error1("Call with a Void target.",position);
#endif
    return NULL;
  }
}

T0* se_string_inspect_check(T0* o, se_position position) {
  /*
    Void check for expression of type STRING in inspect.
  */
  if (o != NULL) {
    return o;
  }
  else {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Incorrect_inspect_value);
#else
    error1("Expression just after \"inspect\" is Void.",position);
#endif
    return NULL;
  }
}

T0* ci(int id, T0* o, se_position position) {
  /*
    Check Id for reference target.
  */
  if ( vc(o,position) != NULL) {
    if ( id == (o->id) ) {
      return o;
    }
    else {
#ifdef SE_EXCEPTIONS
      internal_exception_handler(System_level_type_error);
#else
      int l = se_position2line(position);
      int c = se_position2column(position);
      int f = se_position2path_id(position);

      se_print_bad_target(SE_ERR,id,o,l,c,f);
      se_print_run_time_stack();
      se_print_bad_target(SE_ERR,id,o,l,c,f);
#ifdef SE_SEDB
      sedb_break(se_dst,0);
#else
      exit(EXIT_FAILURE);
#endif
#endif
    }
  }
  return o;
}

void ac_req(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Precondition);
#else
    error0("Require Assertion Violated.",vv);
#endif
  }
}

void ac_ens(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Postcondition);
#else
    error0("Ensure Assertion Violated.",vv);
#endif
  }
}

void ac_inv(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Class_invariant);
#else
    error0("Class Invariant Violation.",vv);
#endif
  }
}

void ac_liv(int v,char*vv) {
  /* Assertion Check : Loop Invariant check. */
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Loop_invariant);
#else
    error0("Loop Invariant Violation.",vv);
#endif
  }
}

int ac_lvc(int lc,int lv1,int lv2) {
  /* Assertion Check : Loop Variant check. */
  if (lc == 0) {
    if (lv2 < 0) {
#ifdef SE_EXCEPTIONS
      internal_exception_handler(Loop_variant);
#else
      {
	char msg [64];
	sprintf(msg,"Bad First Variant Value = %d\n",lv2);
	error0(msg,NULL);
      }
#endif
    }
    else {
      return lv2;
    }
  }
  else if ((lv2 < 0) || (lv2 >= lv1)) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Loop_variant);
#else
    {
      char msg [512];
      sprintf(msg,
	      "Bad loop variant.\nLoop body counter = %d (done)\n"
	      "Previous Variant = %d\nNew Variant = %d\n",
	      lc,lv1,lv2);
      error0(msg,NULL);
    }
#endif
  }
  return lv2;
}

void ac_civ(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Check_instruction);
#else
    error0("Check Assertion Violated.",vv);
#endif
  }
}

T0* se_evobt(T0* o, se_position position) {
    /*
      Error Void Or Bad Type.
    */
    if (!o) {
#ifdef SE_EXCEPTIONS
	internal_exception_handler(Void_call_target);
#else
	error1("Target is Void.",position);
#endif
    }
    else {
#ifdef SE_EXCEPTIONS
	internal_exception_handler(System_level_type_error);
#else
	error2(o,position);
#endif
    }
    return o; /* Dummy return to avoid C warnings. */
}

void se_signal_handler(int sig) {
  printf("Received signal %d.\n",sig);
#ifdef SE_SEDB
  signal(sig,se_signal_handler);
  sedb_signal_handler(sig);
#else
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
}

void se_gc_check_id(void*o,int id) {
  if (id != (((T0*)o)->id)) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Routine_failure);
#else
    fprintf(SE_ERR,"System-validity error detected during GC cycle.\n");
    se_print_bad_target(SE_ERR,id,(T0*)o,0,0,0);
    se_print_run_time_stack();
    fprintf(SE_ERR,"System-validity error detected during GC cycle.\n");
    se_print_bad_target(SE_ERR,id,(T0*)o,0,0,0);
    exit(EXIT_FAILURE);
#endif
  }
}

se_dump_stack* se_new_dump_stack(se_dump_stack* copy) {
  se_dump_stack* result = NULL;
  se_frame_descriptor* fd;
  int i, j, o, p, n;
  int local_count;
  char* local_format;
  int id;
  void** var;
  int local_size;
  int expanded;

  void*** _i;
  void** _ref;
  char*  _exp;

  if (copy != NULL) {
    fd = copy->fd;
    result = (se_dump_stack*)se_malloc(sizeof(se_dump_stack));
    if (result != NULL) {
      result->fd               = fd;
      result->p                = copy->p;
      result->caller           = copy->caller;
      result->current          = NULL;
      result->locals           = NULL;
      result->exception_origin = NULL;

      if (fd != NULL) {
	local_format = fd->local_format;
	i = 0;
	if (fd->use_current) {
	  result->current = copy->current;
	  /* Place i after the Current definition: */
	  i = 2;
	  id = 0;
	  while (local_format[i] != '%') {
	    id = (id * 10) + (local_format[i++] - '0');
	  }
	  i++;
	}

	/*
	 *
	 * p: sum of the number of pointers ("indirections") per local
	 *    -> 1 for an expanded
	 *    -> 2 for a reference
	 *
	 * o: total malloc'ed size
	 *
	 * _i: access to the first indirection pointer
	 *
	 * _ref: access to the second indirection pointer of a reference object
	 *       _ref == (T0*)(*_i)
	 *
	 * _exp: access to a copy of the expanded object
	 *       _exp == *((char*)_i)
	 *
	 *
	 *
	 * For instance, if "0" is the first local, a reference and "4" is the
	 * second local, an expanded type (say, a 6-byte structure noted
	 * "XXXXXXXXXXX", with 64-bit padding "/"):
	 *
	 *
	 *
	 * result->locals
	 *       |                ------------
	 *       |               |            |
	 *       |    -----------|------------v--------------
	 *        -->| | | | |===+===|===+===|XXXXXXXXXXX|/|/|
	 *           |0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|0|1|2|3|
	 *           |===+===| | | | |===+===| | | | | | | | |
	 *            ---|------------^--|-------------------
	 *               |            |  |
	 *                ------------    --------------------------> object
	 *
	 *           |-> _i          |-> _ref         _exp <-|
	 *
	 *
	 *
	 * Note: Those "|->" denote the start value and way of
	 *       progression of the pointers
	 *
	 *
	 * result->locals is defined as a (void***) but its real "type" depends on
	 * which element is accessed (as in the live stack; but in the live stack,
	 * only the first indirection is in the struct; the remaining data is on
	 * the native stack).
	 *
	 */

	if (copy->locals != NULL) {
	  j = i;

	  local_count = local_size = p = o = 0;

	  while (local_count < fd->local_count) {
	    while (local_format[i++] != '%');
	    expanded = ((local_format[i++] == 'E')?1:0);
	    id = 0;
	    while (local_format[i] != '%') {
	      id = (id * 10) + (local_format[i++] - '0');
	    }
	    i++;
	    if (expanded) {
	      p++;
	      o = se_strucT[id];
	      o = (o + 7) & ~7; /* 64-bit align: should be fine for most systems */
	      local_size += o;
	    }
	    else {
	      p+=2;
	    }
	    local_count++;
	  }

	  o = p * sizeof(void*) + local_size;
	  result->locals = (void***)se_malloc(o);
	  _i   = result->locals;
	  _exp = (char*)_i + o;
	  _ref = (void**)_i + local_count;

	  i = j;
	  local_count = 0;
	  while (local_count < fd->local_count) {
	    while (local_format[i++] != '%');
	    expanded = ((local_format[i++] == 'E')?1:0);
	    id = 0;
	    while (local_format[i] != '%') {
	      id = (id * 10) + (local_format[i++] - '0');
	    }
	    i++;
	    var = (copy->locals)[local_count];
	    if (expanded) {
	      o = n = se_strucT[id];
	      o = (o + 7) & ~7; /* 64-bit align: should be fine for most systems */
	      _exp -= o;
	      *(char**)_i = _exp;
	      memset(_exp, 0, o);
	      memcpy(_exp, var, n);
	    }
	    else {
	      *_i = _ref;
	      *_ref = *var;
	      _ref++;
	    }
	    local_count++;
	    _i++;
	  }
	}
      }
    }
  }
  return result;
}

void se_delete_dump_stack(se_dump_stack* ds) {
  if (ds != NULL) {
    if (ds->locals != NULL) free(ds->locals);
    free(ds);
  }
}


void se_print_locals_in(FILE* file, se_dump_stack* ds, int enter) {
  se_frame_descriptor* fd = ds->fd;
  int i = 0;
  int local_count = 0;
  char* local_format;
  int expanded;
  int id;
  void** var;
  int printed = 0;
  int display;

  if (ds->p == 0) return;
  local_format = fd->local_format;
  if (fd->use_current) {
    i = 2;
    id = 0;
    while (local_format[i] != '%') {
      i++;
    }
    i++;
  }
  while (local_count < fd->local_count) {
    display = (strncmp(local_format+i, "Result%", 7)==0) != enter;
    if (display) {
      if (printed)
	fprintf(file,", ");
      else
	fprintf(file,"(");
      printed++;
    }
    
    while (local_format[i] != '%') {
      if (display) fprintf(file,"%c",local_format[i]);
      i++;
    }
    i++;
    expanded = ((local_format[i++] == 'E')?1:0);
    if (display) fprintf(file," = ");
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    if (display) {
      if (ds->locals == NULL) {
	fprintf(file,"<unavailable>");
      }
      else {
	var = (ds->locals)[local_count];
	if (expanded) {
	  (se_prinT[id])(file, (void**)(var));
	}
	else if (*var == NULL) {
	  fprintf(file,"Void");
	}
	else {
	  (se_prinT[((T0*)(*var))->id])(file, (void**)(var));
	}
      }
    }
    local_count++;
  }
  if (printed)
    fprintf(file,")\n");
  else
    fprintf(file,"\n");

}

#ifdef SE_TRACE
static int se_call_depth=0;

void se_print_call_trace(se_dump_stack *ds) {
  int i;
  if (ds) {
    int enter = ds->caller == se_dst;
    
    if (enter)
      se_call_depth++;

    if (se_call_depth < 0)
      se_call_depth=0;

    for(i=se_call_depth<<1; i; i--)
      putchar(' ');

    if (enter) {
      printf("enter ");
      printf("%s", ds->fd->name);
      se_print_locals_in(stdout, ds, 1);
    } else {
      if (se_dst) {
	printf("leave ");
	printf("%s", se_dst->fd->name);
	se_print_locals_in(stdout, se_dst, 0);
	se_call_depth--;
      }
    }
  } else {
    for(i=se_call_depth<<1; i; i--)
      putchar(' ');
    printf("leave ");
    printf("%s", se_dst->fd->name);
    se_print_locals_in(stdout, se_dst, 0);
    se_call_depth--;
  }
}
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/

/*
   This file (SmartEiffel/sys/runtime/gc_lib.c) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has been
   selected).
*/
/*
   The `mark_stack_and_registers' C function is called by the Garbage
   Collector (GC) of SmartEiffel. It has to be customized for some systems,
   but also for some C compilers. This file provides some definitions in the
   end and has to be completed for systems which need specific work.

   On some architectures, addresses increase as the stack grows; or,
   conversely, addresses decrease as the stack grows. A C compiler may be
   clever enough to hide some root object inside registers. Unfortunately all
   registers are not always accessible via the C `setjmp' function!

   Thus, in order to be able to use the GC on your architecture/C-compiler,
   you have to provide the correct `mark_stack_and_registers' function.

   What is the `mark_stack_and_registers' function supposed to do?  The
   `mark_stack_and_registers' function is supposed to notify the GC with all
   the possible roots one can find in the C stack and registers by calling the
   `gc_mark' function. A root is an object which must not be collected.  The
   SmartEiffel GC already knows about some root objects like once function
   results or manifest strings. The `mark_stack_and_registers' function has to
   notify the other possible roots. Obviously, one can find in the C stack any
   kind of adresses, but the `gc_mark' function is clever enough to determine
   if the passed pointer is an Eiffel object or not.  When the passed pointer
   reaches some Eiffel object, this object as well as its descendant(s) are
   automatically marked as un-collectable.

   In order to provide the most appropriate `mark_stack_and_registers'
   function, the very first question is to know about the way the C stack is
   managed (addresses of the stack may increase or decrease as the C stack
   grows). The DEFAULT BEHAVIOUR FOR UNKNOWN SYSTEMS is to consider ADDRESSES
   DECREASE AS THE STACK GROWS, as it's the most common case.  The global C
   variable `stack_bottom' is set with some pointer which is supposed to be
   the bottom of the stack (this variable is automatically initialized in the
   C main function).  Note: using the current stack pointer inside
   `mark_stack_and_registers', it is quite obvious to determine if addresses
   increase or not as the C stack grows.  Note2: on some systems, the stack is
   not in contiguous addresses. In such case, `mark_stack_and_registers' has
   to go through all the stack fragments.

   Some roots may be stored only in registers and not in the C stack.  In
   order to reach the registers as well, the first attempt is to use setjmp,
   in the hope that setjmp will save registers in the stack!  Note: this
   technique do not work on processors using windows registers (such as sparc
   processors).

*/

int se_gc_strategy = SE_GC_DEFAULT_MEMORY_STRATEGY;

int collector_counter = 0;

static void gcna_align_mark(rsoc*c,void*o);
static rsoc*rsocfl=NULL; /* ReSizable Object Chunk Free List. */

void**stack_bottom=NULL;
mch**gcmt=NULL; /* Garbage Collector Main Table. */
int gcmt_max=2048;
int gcmt_used=0;
fsoc*fsocfl=NULL; /* Fixed Size Object Chunk Free List. */
int gc_is_off=1;
unsigned int fsoc_count=0;
unsigned int rsoc_count=0;
void*gcmt_tail_addr=NULL;

static int chunk_rounded(int size) {
  int rounded_size = size;
  int diff = rounded_size%RSOC_SIZE;

  if (diff != 0) rounded_size += (RSOC_SIZE-diff);
  return rounded_size;
}

/* Return the index where chunk `c' is (or is to be) in the `gcmt', 
   between `min' and `max' indexes. */
static unsigned int binary_search_in_gcmt(register unsigned int min, 
					  register unsigned int max, 
					  register mch* c){
  register unsigned int mid;
  while (min<max){
    mid=(min+max)>>1;
    if (gcmt[mid]<c)
      min=mid+1;
    else
      max=mid;
  }
  if (gcmt[min]<c)
    return min+1;
  else
    return min;
}

static void may_free_rsocfl(void) {
  /* May free all chunks of `rsocfl' (ReSizable Object Chunk Free List)
     in some circumstances.
  */
  rsoc* next; register rsoc *current;
  unsigned int count = rsocfl_count();
  register unsigned int where = gcmt_used;
  register unsigned int how_many;

  if ((count > 50) && (count > (rsoc_count >> 1))) {
    current=rsocfl;
    rsocfl=NULL;
    while (NULL != current) {
      next=current->next;
      if (current->isize == current->header.size) {
	where = binary_search_in_gcmt(0, where-1, (mch*)current);
	how_many = gcmt_used - 1 - where;
	if (how_many > 0)
	  memmove(gcmt+where, gcmt+where+1, how_many*sizeof(mch*));
	free(current); gcmt_used--; rsoc_count--;
      }
      else {
	current->next=rsocfl;
	rsocfl=current;
      }
      current = next;
    }
  }
}

int gc_memory_used(void) {
  int i;
  int result = 0;
  mch* mch;
  for (i = gcmt_used; i --> 0; ) {
    mch = gcmt[i];
    switch(mch->state_type) {
    case RSO_USED_CHUNK:
    case FSO_USED_CHUNK:
    case FSO_STORE_CHUNK:
      result += mch->size;
      break;
    default:
      break;
    }
  }
  return result;
}

void gc_sweep(void) {
  mch** p2 = gcmt;
  mch** p1 = gcmt+1;
  mch**eogcmt=gcmt+gcmt_used;
  if (FREE_CHUNK((*p2)->state_type)) {
    if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  else {
    ((*gcmt)->swfp)(*p2);
    if (RSO_FREE_CHUNK==((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  while (p1 < eogcmt) {
    if (FREE_CHUNK((*p1)->state_type)) {
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if ( (((rsoc*)*p1)->isize==0) && ((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
    else {
      ((*p1)->swfp)(*p1);
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if ( (((rsoc*)*p1)->isize==0) && ((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
  }
  gcmt_used=(p2-gcmt)+1;
  may_free_rsocfl();
}

/* return the mch containing p or NULL if p is not 
 * a valid address or was externally allocated 
 */
mch * gc_find_chunk(void * p){
  if ((p>((void*)*gcmt))&&(p<=gcmt_tail_addr)) {
    int i1=0;
    int i2=gcmt_used-1;
    int m=i2>>1;
    mch*c;
    for (;i2>i1;m=((i1+i2)>>1)) {
      if (p<=((void*)gcmt[m+1])) {
	i2=m;
      }
      else {
	i1=m+1;
      }
    }
    c=gcmt[i2];
    if((char*)p<(char*)c+c->size)   /* check for upper bound */
      if (!(FREE_CHUNK(c->state_type))){
	return c;
      }
  }
  return NULL;
}

void gc_mark(void*p) {
  mch * c;
  c = gc_find_chunk(p);
  if(NULL != c) {
    (c->amfp)(c,p);
  }
}

int gc_stack_size(void) {
  void*stack_top[2]={NULL,NULL};
  if (stack_top > stack_bottom) {
    return ((void**)stack_top)-((void**)stack_bottom);
  }
  else {
    return ((void**)stack_bottom)-((void**)stack_top);
  }
}

/*
  To delay Garbage Collection when the stack is too large.
  To allow fast increase of ceils.
*/
#define FSOC_LIMIT (10240/((FSOC_SIZE)>>10))
#define RSOC_LIMIT (10240/((RSOC_SIZE)>>10))

/*
  When stack is too large, collection may be delayed.
*/
#define GCLARGESTACK 50000

int garbage_delayed(void) {
  /*
    To delay the first GC call.
  */
  if (gc_stack_size() > GCLARGESTACK) {
    if (fsoc_count_ceil <= fsoc_count) {
      if (rsoc_count_ceil <= rsoc_count) {
	if ((fsoc_count<FSOC_LIMIT)&&(rsoc_count<RSOC_LIMIT)) {
	  fsoc_count_ceil++;
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else {
	if (fsoc_count<FSOC_LIMIT) {
	  fsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
    }
    else {
      if (rsoc_count_ceil <= rsoc_count) {
	if (rsoc_count<RSOC_LIMIT) {
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else return 0;
    }
  }
  else {
    return 0;
  }
}

void gc_update_ceils(void) {
  /* This function is automatically called after each collection
     cycle.
  */
  if (se_gc_strategy == SE_GC_LOW_MEMORY_STRATEGY) {
    fsoc_count_ceil = fsoc_count;
    rsoc_count_ceil = rsoc_count;
    /* Todo: we should also consider to free unused chunks here. */
    return;
  }
  if (se_gc_strategy == SE_GC_HIGH_MEMORY_STRATEGY) {
    fsoc_count_ceil = (256 + fsoc_count) << 2;
    rsoc_count_ceil = (256 + rsoc_count) << 2;
    return;
  }
  /* The SE_GC_DEFAULT_MEMORY_STRATEGY. */
  /* Compute fsoc_count_ceil: */

  /* The lines commented out with --perf-- were killing performance under certain circumstances, *
   * especially with gcc -O3 <FM-15/04/2005>                                                     */

  /* --perf-- if (fsocfl == NULL) { */
  if (fsoc_count >= fsoc_count_ceil) {
    if (fsoc_count_ceil < FSOC_LIMIT) {
      fsoc_count_ceil <<= 1;
    }
    else {
      unsigned int c = fsoc_count + (fsoc_count/3);
      if (fsoc_count_ceil < c)
	fsoc_count_ceil = c;
    }
  }
  /* --perf-- }
     else {
     if (fsoc_count_ceil < fsoc_count) {
     fsoc_count_ceil = fsoc_count;
     }
     }
  */
  /* Compute rsoc_count_ceil: */
  /* --perf-- if (rsocfl == NULL) {*/
  if (rsoc_count >= rsoc_count_ceil) {
    if (rsoc_count_ceil < RSOC_LIMIT) {
      rsoc_count_ceil <<= 1;
    }
    else {
      unsigned int c = rsoc_count + (rsoc_count / 3);
      if (rsoc_count_ceil < c) {
	rsoc_count_ceil = c;
      }
    }
  }
  /* --perf -- }
     else {
     if (rsoc_count_ceil < rsoc_count) {
     rsoc_count_ceil = rsoc_count;
     }
     }
  */
}

static void gc_add_into_gcmt(mch*c) {
  /* Update the `gcmt' (Garbage Collector Main Table) by adding the
     new `mch' (Memory Chunk Header).`gcmt_used' is updated.
  */
  unsigned int where=0;
  unsigned how_many;
  if (gcmt_used>0){
    where=binary_search_in_gcmt(0, gcmt_used-1, c);
    if (gcmt_used == gcmt_max) {
      gcmt_max <<= 1;
      gcmt = ((mch**)(se_realloc(gcmt,(gcmt_max+1)*sizeof(void*))));
    }
    how_many = gcmt_used - where;
    if (how_many > 0)    
      memmove(gcmt+where+1, gcmt+where, how_many*sizeof(mch*));
  }
  gcmt[where]=c;
  gcmt_used++;
}

static char*rso_from_store(na_env*nae,unsigned int size) {
  rsoh*r=(nae->store);
  nae->store_left-=size;
  if ((nae->store_left) > sizeof(rsoh)) {
    r->header.size=size;
    nae->store=((rsoh*)(((char*)(nae->store))+size));
  }
  else {
    r->header.size=size+nae->store_left;
    nae->store_left=0;
  }
  (r->header.magic_flag)=RSOH_UNMARKED;
  ((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
  return (char*)(r+1);
}

static void rsoc_sweep(rsoc*c) {
  na_env*nae=c->nae;
  rsoh*gp=(rsoh*)&(c->first_header);
  rsoh*pp;
  rsoh*eoc=((rsoh*)(((char*)c)+c->header.size));
  c->free_list_of_large=NULL;
  if (c->header.size > RSOC_SIZE) {
    if (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      /* No need to register chunks with no free_list_of_large
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      */
    }
    else {
      c->header.state_type=RSO_FREE_CHUNK;
    }
    return;
  }
  while (gp<eoc) {
    while (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      gp=((rsoh*)(((char*)gp)+gp->header.size));
      if(gp>=eoc) {
	/* No need to register chunks with no free_list_of_large
	c->next=nae->chunk_list;
	nae->chunk_list=c;
	*/
	return;
      }
    }
    gp->header.magic_flag=RSOH_FREE;
    pp=(rsoh*)(((char*)gp)+gp->header.size);
    while ((pp<eoc)&&(pp->header.magic_flag != RSOH_MARKED)) {
      gp->header.size+=pp->header.size;
      pp=((rsoh*)(((char*)pp)+pp->header.size));
    }
    if (gp->header.size >= RSOC_MIN_STORE) {
      if (nae->store_left==0) {
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else if (nae->store->header.size < gp->header.size) {
	((fll_rsoh*)nae->store)->nextflol=nae->store_chunk->free_list_of_large;
	nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else {
	((fll_rsoh*)gp)->nextflol=c->free_list_of_large;
	c->free_list_of_large=((fll_rsoh*)gp);
      }
    }
    gp=pp;
  }
  if (((rsoh*)(&c->first_header))->header.size >=
      (c->header.size-sizeof(rsoc)+sizeof(rsoh))){
    c->header.state_type=RSO_FREE_CHUNK;
    nae->store_chunk=NULL;
    nae->store_left=0;
  }
  else{
    c->next=nae->chunk_list;
    nae->chunk_list=c;
  }
}

/* *** To be removed */
#ifdef __TINYC__
static rsoc MRSOC = {
#else
static const rsoc MRSOC = {
#endif
    {
	RSOC_SIZE,
	RSO_USED_CHUNK,
	((void(*)(mch*,void*))gcna_align_mark),
	((void(*)(mch*))rsoc_sweep)
    },
    0,
    NULL,
    NULL,
    NULL,
    {
      {
	0,
	RSOH_MARKED
      }
    }
};

static void rsoc_malloc(na_env*nae) {
  rsoc* r = ((rsoc*)(se_malloc(RSOC_SIZE)));
  rsoc_count++;
  *r=MRSOC;
  r->nae=nae;
  r->isize=RSOC_SIZE;
  nae->store=(&(r->first_header));
  nae->store_left=RSOC_SIZE-sizeof(rsoc)+sizeof(rsoh);
  nae->store_chunk=r;
  r->next=nae->chunk_list;
  nae->chunk_list=r;
  gc_add_into_gcmt((mch*)r);
}

static rsoc* rsocfl_best_fit(unsigned int size) {
  register unsigned int best_size = 0;
  unsigned int acceptable_loss;
  register rsoc *pc, *best_pc, *best_c, *c;
  if (NULL==rsocfl)
    return NULL;
  pc=NULL;
  best_pc=NULL;
  best_c=NULL;
  c=rsocfl;
  if (SE_GC_DEFAULT_MEMORY_STRATEGY == se_gc_strategy)
    acceptable_loss = (size >> 4);
  else if (SE_GC_LOW_MEMORY_STRATEGY == se_gc_strategy)
    acceptable_loss = 0;
  else /* SE_GC_HIGH_MEMORY_STRATEGY == se_gc_strategy */
    acceptable_loss = (size >> 2);

  while ((NULL!=c)&&(NULL==best_c)){
    if (c->header.size>=size){
      best_c=c;
      best_pc=pc;
      best_size=c->header.size;
    }
    pc=c;
    c=c->next;
  }
  if (NULL==c){
    if (NULL != best_pc)
      best_pc->next=best_c->next;
    else if (best_c==rsocfl)
      rsocfl=best_c->next;
    return best_c;
  }
  if ((best_size - size) > acceptable_loss){
    do {
      if ((c->header.size >= size) && (c->header.size < best_size)) {
	best_c = c;
	best_pc = pc;
	best_size = c->header.size;
	if ((best_size - size) <= acceptable_loss) break;
      }
      pc=c;
      c=c->next;
    }
    while(NULL!=c);
  }
  if (NULL==best_pc) {
    rsocfl = best_c->next;
  }
  else {
    best_pc->next=best_c->next;
  }
  return best_c;
}

static int get_store_in(rsoc*c,unsigned int size) {
  na_env*nae=c->nae;
  fll_rsoh*pf=NULL;
  fll_rsoh*f=c->free_list_of_large;
  while (f != NULL) {
    if (f->rsoh_field.size >= size) {
      nae->store_left=f->rsoh_field.size;
      nae->store=(rsoh*)f;
      nae->store_chunk=c;
      if (pf == NULL) {
	c->free_list_of_large=f->nextflol;
      }
      else {
	pf->nextflol=f->nextflol;
      }
      return 1;
    }
    pf = f;
    f = f->nextflol;
  }
  return 0;
}

char*new_na_from_chunk_list(na_env*nae,unsigned int size) {
  rsoc*c=nae->chunk_list;
  unsigned int csize;
  while (c != NULL) {
    if (get_store_in(c,size)) {
      return rso_from_store(nae,size);
    }
    c = c->next;
  }
  csize=size+(sizeof(rsoc)-sizeof(rsoh));
  c=rsocfl_best_fit(csize);
  if (c != NULL){
    if (c->header.size > RSOC_SIZE) {
      if (c->header.size-csize > RSOC_MIN_STORE*4) {
	int csize_left=c->header.size-csize;
	if ((csize_left%sizeof(double))!=0) {
	  csize_left-=(csize_left%sizeof(double));
	  csize=c->header.size-csize_left;
	}
	c->header.size=csize_left;
	c->next=rsocfl;
	rsocfl=c;
	c=(rsoc*)(((char*)c)+csize_left);
	c->isize=0; /* c split from a larger chunk */
	gc_add_into_gcmt((mch*)c);      
	c->header.amfp=(void(*)(mch*,void*))gcna_align_mark;
	c->header.swfp=(void(*)(mch*))rsoc_sweep;
      }
      /* since objects bigger than RSOC_SIZE must be the only object in their chunk, we do not want to have
	 some store left after them. Therefore, we do not set csize to c->header.size in an else block
	 here. */
      c->header.size=csize;
    }
    else {
      csize=c->header.size;
    }
    c->header.state_type=RSO_USED_CHUNK;
    c->free_list_of_large=NULL;
    c->nae=nae;
    nae->store=(&(c->first_header));
    nae->store_left=csize-sizeof(rsoc)+sizeof(rsoh);
    nae->store_chunk=c;
    /* No need to register chunks with no free_list_of_large
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    */
    return rso_from_store(nae,size);
  }
  return NULL;
}

/* size in bytes, including header size */
char*new_na(na_env*nae,unsigned int size) {
  if (size == 0) {
#ifdef SE_BOOST
    handle(SE_HANDLE_RUNTIME_ERROR, NULL);
    se_print_run_time_stack();
    exit(EXIT_FAILURE);
#else
    char msg[512];
    sprintf(msg, "Bad native array size: %d.\n", size);
    error0(msg, NULL);
#endif
  }
  if (nae->store_left>0) {
    nae->store->header.size=nae->store_left;
    nae->store->header.magic_flag=RSOH_FREE;
    if (nae->store_left >= RSOC_MIN_STORE) {
      ((fll_rsoh*)(nae->store))->nextflol=nae->store_chunk->free_list_of_large;
      nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
    }
    nae->store_left=0;
  }
  if ((nae->store_chunk!=NULL)&&(get_store_in(nae->store_chunk,size))) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL)
      return r;
  }
  if (rsoc_count<rsoc_count_ceil) {
    if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
      rsoc*c;
      rsoh*r;
      unsigned int rounded_size= chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
      c=((rsoc*)(se_malloc(rounded_size)));
      r=(&(c->first_header));
      rsoc_count++;
      *c=MRSOC;
      c->isize = rounded_size;
      c->header.size=rounded_size;
      c->nae=nae;
      /* No need to register chunks with no free_list_of_large
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      */
      gc_add_into_gcmt((mch*)c);
      r->header.size=size;
      (r->header.magic_flag)=RSOH_UNMARKED;
      ((void)memset((r+1),0,size-sizeof(rsoh)));
      return (char*)(r+1);
    }
    else {
      rsoc_malloc(nae);
      return rso_from_store(nae,size);
    }
  }
  gc_start();
  if (size<=(nae->store_left)) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL) {
      return r;
    }
  }
  if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
    rsoc*c;
    rsoh*r;
    unsigned int rounded_size = chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
    c=((rsoc*)(se_malloc(rounded_size)));
    r=(&(c->first_header));
    rsoc_count++;
    *c=MRSOC;
    c->isize = rounded_size;
    c->header.size=rounded_size;
    c->nae=nae;
    /* No need to register chunks with no free_list_of_large
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    */
    gc_add_into_gcmt((mch*)c);
    r->header.size=size;
    (r->header.magic_flag)=RSOH_UNMARKED;
    ((void)memset((r+1),0,size-sizeof(rsoh)));
    gc_update_ceils();
    return (char*)(r+1);
  }
  else {
    rsoc_malloc(nae);
    gc_update_ceils();
    return rso_from_store(nae,size);
  }
}

static void gcna_align_mark(rsoc*c,void*o) {
  na_env* nae = c->nae;
  fll_rsoh* f;
  fll_rsoh* pf;
  char* b = (char*)&(c->first_header);

  /* properly aligned ? */
  if (((((char*)o)-((char*)c))%sizeof(int)) != 0) {
      return;
  }
  /* already marked ? */
  if ((((rsoh*)o)-1)->header.magic_flag != RSOH_UNMARKED) {
      return;
  }
  if (((char*)o) < ((char*)(c+1))) {
      return;
  }
  /* a large chunck ? */
  if (c->header.size > RSOC_SIZE) {
      if (o == (c+1)) {
	nae->gc_mark((T0*)o);
      }
      return;
  }
  pf=NULL;
  f=c->free_list_of_large;
  while ((f != NULL) && (f < ((fll_rsoh*)o))) {
      pf=f;
      f=f->nextflol;
  }
  if (pf == NULL) {
      pf=(fll_rsoh*)b;
  }
  while ((((rsoh*)pf)+1) < (rsoh*)o) {
      pf = ((fll_rsoh*)(((char*)pf)+pf->rsoh_field.size));
  }
  if (o == (((rsoh*)pf)+1)) {
    nae->gc_mark((T0*)o);
  }
}

unsigned int rsocfl_count(void) {
  /* Returns the number of items in the ReSizable Object Free List.
  */
  register unsigned int r=0;
  register rsoc*p=rsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

unsigned int fsocfl_count(void) {
  register unsigned int r=0;
  register fsoc*p=fsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

void gc_dispose_before_exit(void) {
  mch** p = gcmt;
  mch**eogcmt=gcmt+gcmt_used;

  while (p < eogcmt) {
    if (((*p)->state_type == FSO_STORE_CHUNK) ||
	((*p)->state_type == FSO_USED_CHUNK)) {
      ((*p)->swfp)(*p);
    }
    p++;
  }
}

fsoc* gc_fsoc_get1(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) from the free fsoc list or
     allocate a new one (using `se_malloc') only when the ceil is not
     yet reached. Otherwise, call the `gc_start()' function and
     return NULL.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl = fsocfl->next;
    return result;
  }
  else if (fsoc_count_ceil > fsoc_count) {
    result = ((fsoc*)se_malloc(FSOC_SIZE));
    fsoc_count++;
    gc_add_into_gcmt((mch*)result);
    return result;
  }
  else {
    gc_start();
    return NULL;
  }
}

fsoc* gc_fsoc_get2(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) or force the allocation of a
     new `fsoc' (using the `se_malloc' function). Update various ceils
     accordingly.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl=fsocfl->next;
    return result;
  }
  else {
    result = ((fsoc*)(se_malloc(FSOC_SIZE)));
    fsoc_count++;
    gc_update_ceils();
    gc_add_into_gcmt((mch*)result);
    return result;
  }
}

#if defined(__sparc__) || defined(sparc) || defined(__sparc)
/* For SPARC architecture.
   As this part contains assembly code (asm), you must not use
   the flag -ansi of gcc compiler.
*/

void mark_loop(void) {
  void** max = stack_bottom;
  void** stack_pointer;
  void* stack_top[2]={NULL,NULL};
  stack_pointer = stack_top;
  /* Addresses decrease as the stack grows. */
  while (stack_pointer <= max) {
    gc_mark(*(stack_pointer++));
  }
}

void mark_stack_and_registers(void) {
#  if defined(__sparcv9)
  asm(" flushw");
#  else
  asm(" ta      0x3   ! ST_FLUSH_WINDOWS");
#  endif
  mark_loop();
}

#elif defined(__ELATE__) || defined(ELATE)
/* GNU Eiffel's VP (Virtual Processor) garbage collector for Elate.
   (c) 2000 Rudi Chiarito <rudi@amiga.com>

   Thanks to Andy Stout and Kevin Croombs at Tao Group for their
   precious help!

   ChangeLog:
   - 2000-06-12 Rudi Chiarito <rudi@amiga.com>
     * Version 1.0
   - 2001-01-01 Joseph Kiniry <kiniry@acm.org>
     * Integrated with new SE 0.75b
   - 2001-08-10 Rudi Chiarito <rudi@amiga.com>
     * Inlined and optimised range marking
     * Added some more comments
     * Added conditional breakpoint in mark_stack_and_registers
   - 2002-09-21 Rudi Chiarito <rudi@amiga.com>
     * Removed redundant 'ret'
*/

__inline__ void mark_stack_and_registers(void)
{

  void *pointer_to_gc_mark = &gc_mark;

  __asm__ __volatile__
  (
    /*
      WARNING: funky code ahead!
      \t and \n are needed to make the final output easier to read
      while debugging. Hopefully you'll never have to bother with all
      of this.

      Registers:
        p0  pointer to stack block
        p1  pointer to gc_mark()
        p2  scratch pointer
        i0  length of current stack block
        i1  scratch register
    */

#  ifdef __ELATE_SE_DEBUG_GC
   "\tqcall sys/cii/breakpt,(-:-)\n"
#  endif

   "\tsync\n"                          /* spill all the registers */
   "\tsyncreg\n"                       /* to the stack */

   "\tcpy.p %0,p1\n"                   /* pointer to gc_mark() */

   /* pointer to the current stack block */
   "\tcpy.p [gp+PROC_STACK],p0\n"

   /* point to last location in the block, before the descriptor */
   "\tcpy.p p0 + ([(p0 - STK_SIZE) + STK_LENGTH] - STK_SIZE - 4),p2\n"

   /* mark the contents of the current stack block */
   "\twhile p2>=sp\n"
      "\t\tgos p1,(p2 : -)\n"
      "\t\tsub.p 4,p2\n"
   "\tendwhile\n"

   /* now scan other blocks (if any) */

   "\tloop\n"
      "\t\tcpy.p [p0 - STK_SIZE + STK_LINK],p0\n" /* get next block */
      "\t\tbreakif p0=NULL\n"

      /* point to last location in the block, before the descriptor */
      "\t\tcpy.p p0 + ([(p0 - STK_SIZE) + STK_LENGTH] - STK_SIZE - 4),p2\n"

      /* mark this block */
      "\t\twhile p2>=p0\n"

         "\t\t\tgos p1,(p2 : -)\n"
         "\t\t\tsub.p 4,p2\n"
      "\t\tendwhile\n"
   "\tendloop\n"

   : /* no output */
   : "p" (pointer_to_gc_mark)
   : "p0", "p1", "p2", "i0" 
   );
}

#elif defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)

/****************************************************************************
 * Generic code for architectures where addresses increase as the stack grows.
 ****************************************************************************/

void mark_stack_and_registers(void){
  void** max = stack_bottom;
  JMP_BUF registers;   /* The jmp_buf buffer is in the C stack. */
  void**stack_pointer; /* Used to traverse the stack and registers assuming
			  that `setjmp' will save registers in the C stack.
		       */

  (void)SETJMP(registers);  /* To fill the C stack with registers. */
  stack_pointer = (void**)(void*)(&registers) + ((sizeof(JMP_BUF)/sizeof(void*))-1);
  /* stack_pointer will traverse the JMP_BUF as well (jmp_buf size is added, 
     otherwise stack_pointer would be below the registers structure). */

#  if !defined(SE_BOOST)
  if (stack_pointer < max) {
    fprintf(stderr, "Wrong stack direction: your stack decrease as the stack grows (or complex stack management). Please drop an e-mail to SmartEiffel@loria.fr\n");
    exit(1); }
#  endif

  while (stack_pointer >= max) {
    gc_mark(*(stack_pointer--));
  }
}
#else

/****************************************************************************
 * Generic code for architectures where addresses decrease as the stack grows.
 ****************************************************************************/

void mark_stack_and_registers(void){
  void** max = stack_bottom;
  JMP_BUF registers;   /* The jmp_buf buffer is in the C stack. */
  void**stack_pointer; /* Used to traverse the stack and registers assuming
			  that `setjmp' will save registers in the C stack.
		       */

  (void)SETJMP(registers);  /* To fill the C stack with registers. */
  stack_pointer = (void**)(void*)(&registers);

#  if !defined(SE_BOOST)
  if (stack_pointer > max) {
    fprintf(stderr, "Wrong stack direction: the stack addresses increase as the stack grows (or complex stack management). Please drop an e-mail to SmartEiffel@loria.fr\n");
    exit(1); }
#  endif

  while (stack_pointer <= max) {
    gc_mark(*(stack_pointer++));
  }
}
#endif

unsigned int fsoc_count_ceil=104;
unsigned int rsoc_count_ceil=27;

/*NATIVE_ARRAY[STRING]*/T0* r185item(se_dump_stack*caller,T185 C,T2 a1){
T0* R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"item"" NATIVE_ARRAY[STRING]",1,2,"%E185%index%E2%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602504/*l37c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602914/*l41c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
R=(C)[a1];
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[STRING]*/T6 r185is_not_null(se_dump_stack*caller,T185 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null"" NATIVE_ARRAY[STRING]",1,1,"%E185%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08630504/*l773c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x08630708/*l775c4/native_array.e*/;
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[STRING]*/void r185put(se_dump_stack*caller,T185 C,T0* a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" NATIVE_ARRAY[STRING]",1,2,"%E185%element%R7%index%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602D04/*l45c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603214/*l50c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
(C)[a2]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603508/*l53c4/native_array.e*/;
ac_ens((r185item(&ds,C,a2))==((void*)(a1)),"item(index) = element");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[STRING]*/T6 r185all_default(se_dump_stack*caller,T185 C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
T0* _v=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"all_default"" NATIVE_ARRAY[STRING]",1,4,"%E185%upper%E2%Result%E6%i%E2%v%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0862CC04/*l716c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0862D014/*l720c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862D50A/*l725c5/native_array.e*/;
R=((T6)(1));
ds.p=0x0862D60A/*l726c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862D80E/*l728c7/native_array.e*/;
tmp0/*or else*/=((T6)(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0862D826/*l728c19/native_array.e*/;
tmp0/*or else*/=((T6)(r6_px_not(&ds,(T6)(R))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0862DA0A/*l730c5/native_array.e*/;
_v=r185item(&ds,C,_i);
ds.p=0x0862DB10/*l731c8/native_array.e*/;
if((_v)!=((void*)((void*)0))){
ds.p=0x0862DC0C/*l732c6/native_array.e*/;
if((_v)==((void*)((void*)0))){
error1("Call on a Void target.",0x0862DC20/*l732c16/native_array.e*/);
}
if((((_v)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0862DC20/*l732c16/native_array.e*/);
}
R=((T6)(r7is_default(&ds,se_i7(&ds,((T7*)(((T7*)_v)))))));
}
ds.p=0x0862DE0A/*l734c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[STRING]*/void r185clear_all(se_dump_stack*caller,T185 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" NATIVE_ARRAY[STRING]",1,3,"%E185%upper%E2%v%R7%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08620A04/*l522c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08620D14/*l525c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862120A/*l530c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862140E/*l532c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0862160A/*l534c5/native_array.e*/;
r185put(&ds,C,_v,_i);
ds.p=0x0862170A/*l535c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08621A08/*l538c4/native_array.e*/;
ac_ens(r185all_default(&ds,C,a1),"all_default(upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[STRING]*/void r185set_all_with(se_dump_stack*caller,T185 C,T0* a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"set_all_with"" NATIVE_ARRAY[STRING]",1,3,"%E185%v%R7%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0861E704/*l487c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0861EA14/*l490c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0861EF0A/*l495c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0861F10E/*l497c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0861F30A/*l499c5/native_array.e*/;
r185put(&ds,C,a1,_i);
ds.p=0x0861F40A/*l500c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[STRING]*/T185 r185realloc(se_dump_stack*caller,T185 C,T2 a1,T2 a2){
T185 R=(void*)0;
void**locals[3];
static se_frame_descriptor fd={"realloc"" NATIVE_ARRAY[STRING]",1,3,"%E185%old_nb_elts%E2%new_nb_elts%E2%Result%E185%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08603904/*l57c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604008/*l64c4/native_array.e*/;
ac_req(r185is_not_null(&ds,C),"is_not_null");
ds.p=0x08604120/*l65c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"old_nb_elts > 0");
ds.p=0x08604220/*l66c16/native_array.e*/;
ac_req(r2_ix_60(&ds,a1,a2),"old_nb_elts < new_nb_elts");
fd.assertion_flag=1;
}
ds.p=0x08604408/*l68c4/native_array.e*/;
R=r185calloc(&ds,C,a2);
ds.p=0x08604516/*l69c11/native_array.e*/;
r185copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604716/*l71c11/native_array.e*/;
ac_ens(r185is_not_null(&ds,R),"Result.is_not_null");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[STRING]*/void r185copy_from(se_dump_stack*caller,T185 C,T185 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from"" NATIVE_ARRAY[STRING]",1,3,"%E185%model%E185%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08622F04/*l559c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08623214/*l562c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862370A/*l567c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0862390E/*l569c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x08623B0A/*l571c5/native_array.e*/;
r185put(&ds,C,r185item(&ds,a1,_i),_i);
ds.p=0x08623C0A/*l572c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[STRING]*/T185 r185calloc(se_dump_stack*caller,T185 C,T2 a1){
T185 R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"calloc"" NATIVE_ARRAY[STRING]",1,2,"%E185%nb_elements%E2%Result%E185%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08601B04/*l27c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08601F20/*l31c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"nb_elements > 0");
fd.assertion_flag=1;
}
R=new185(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602216/*l34c11/native_array.e*/;
ac_ens(r185all_default(&ds,R,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result.all_default(nb_elements - 1)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[UTILISATEUR]*/T0* r184item(se_dump_stack*caller,T184 C,T2 a1){
T0* R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"item"" NATIVE_ARRAY[UTILISATEUR]",1,2,"%E184%index%E2%Result%R61%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602504/*l37c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602914/*l41c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
R=(C)[a1];
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[UTILISATEUR]*/T6 r184is_not_null(se_dump_stack*caller,T184 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null"" NATIVE_ARRAY[UTILISATEUR]",1,1,"%E184%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08630504/*l773c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x08630708/*l775c4/native_array.e*/;
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[UTILISATEUR]*/void r184put(se_dump_stack*caller,T184 C,T0* a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" NATIVE_ARRAY[UTILISATEUR]",1,2,"%E184%element%R61%index%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602D04/*l45c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603214/*l50c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
(C)[a2]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603508/*l53c4/native_array.e*/;
ac_ens((r184item(&ds,C,a2))==((void*)(a1)),"item(index) = element");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[UTILISATEUR]*/T6 r184all_default(se_dump_stack*caller,T184 C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
T0* _v=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"all_default"" NATIVE_ARRAY[UTILISATEUR]",1,4,"%E184%upper%E2%Result%E6%i%E2%v%R61%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0862CC04/*l716c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0862D014/*l720c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862D50A/*l725c5/native_array.e*/;
R=((T6)(1));
ds.p=0x0862D60A/*l726c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862D80E/*l728c7/native_array.e*/;
tmp0/*or else*/=((T6)(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0862D826/*l728c19/native_array.e*/;
tmp0/*or else*/=((T6)(r6_px_not(&ds,(T6)(R))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0862DA0A/*l730c5/native_array.e*/;
_v=r184item(&ds,C,_i);
ds.p=0x0862DB10/*l731c8/native_array.e*/;
if((_v)!=((void*)((void*)0))){
ds.p=0x0862DC0C/*l732c6/native_array.e*/;
if((_v)==((void*)((void*)0))){
error1("Call on a Void target.",0x0862DC20/*l732c16/native_array.e*/);
}
if((((_v)->id))!=(INT8_C(61))){
error1("Bad target type. The expected type is UTILISATEUR.",0x0862DC20/*l732c16/native_array.e*/);
}
R=((T6)(r61is_default(&ds,((T61*)_v))));
}
ds.p=0x0862DE0A/*l734c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[UTILISATEUR]*/void r184clear_all(se_dump_stack*caller,T184 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" NATIVE_ARRAY[UTILISATEUR]",1,3,"%E184%upper%E2%v%R61%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08620A04/*l522c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08620D14/*l525c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862120A/*l530c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862140E/*l532c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0862160A/*l534c5/native_array.e*/;
r184put(&ds,C,_v,_i);
ds.p=0x0862170A/*l535c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08621A08/*l538c4/native_array.e*/;
ac_ens(r184all_default(&ds,C,a1),"all_default(upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[UTILISATEUR]*/void r184set_all_with(se_dump_stack*caller,T184 C,T0* a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"set_all_with"" NATIVE_ARRAY[UTILISATEUR]",1,3,"%E184%v%R61%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0861E704/*l487c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0861EA14/*l490c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0861EF0A/*l495c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0861F10E/*l497c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0861F30A/*l499c5/native_array.e*/;
r184put(&ds,C,a1,_i);
ds.p=0x0861F40A/*l500c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[UTILISATEUR]*/T184 r184realloc(se_dump_stack*caller,T184 C,T2 a1,T2 a2){
T184 R=(void*)0;
void**locals[3];
static se_frame_descriptor fd={"realloc"" NATIVE_ARRAY[UTILISATEUR]",1,3,"%E184%old_nb_elts%E2%new_nb_elts%E2%Result%E184%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08603904/*l57c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604008/*l64c4/native_array.e*/;
ac_req(r184is_not_null(&ds,C),"is_not_null");
ds.p=0x08604120/*l65c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"old_nb_elts > 0");
ds.p=0x08604220/*l66c16/native_array.e*/;
ac_req(r2_ix_60(&ds,a1,a2),"old_nb_elts < new_nb_elts");
fd.assertion_flag=1;
}
ds.p=0x08604408/*l68c4/native_array.e*/;
R=r184calloc(&ds,C,a2);
ds.p=0x08604516/*l69c11/native_array.e*/;
r184copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604716/*l71c11/native_array.e*/;
ac_ens(r184is_not_null(&ds,R),"Result.is_not_null");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[UTILISATEUR]*/void r184copy_from(se_dump_stack*caller,T184 C,T184 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from"" NATIVE_ARRAY[UTILISATEUR]",1,3,"%E184%model%E184%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08622F04/*l559c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08623214/*l562c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862370A/*l567c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0862390E/*l569c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x08623B0A/*l571c5/native_array.e*/;
r184put(&ds,C,r184item(&ds,a1,_i),_i);
ds.p=0x08623C0A/*l572c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[UTILISATEUR]*/T184 r184calloc(se_dump_stack*caller,T184 C,T2 a1){
T184 R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"calloc"" NATIVE_ARRAY[UTILISATEUR]",1,2,"%E184%nb_elements%E2%Result%E184%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08601B04/*l27c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08601F20/*l31c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"nb_elements > 0");
fd.assertion_flag=1;
}
R=new184(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602216/*l34c11/native_array.e*/;
ac_ens(r184all_default(&ds,R,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result.all_default(nb_elements - 1)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[ACTEUR]*/T0* r182item(se_dump_stack*caller,T182 C,T2 a1){
T0* R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"item"" NATIVE_ARRAY[ACTEUR]",1,2,"%E182%index%E2%Result%R60%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602504/*l37c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602914/*l41c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
R=(C)[a1];
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[ACTEUR]*/T6 r182is_not_null(se_dump_stack*caller,T182 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null"" NATIVE_ARRAY[ACTEUR]",1,1,"%E182%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08630504/*l773c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x08630708/*l775c4/native_array.e*/;
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[ACTEUR]*/void r182put(se_dump_stack*caller,T182 C,T0* a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" NATIVE_ARRAY[ACTEUR]",1,2,"%E182%element%R60%index%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602D04/*l45c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603214/*l50c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
(C)[a2]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603508/*l53c4/native_array.e*/;
ac_ens((r182item(&ds,C,a2))==((void*)(a1)),"item(index) = element");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[ACTEUR]*/T6 r182all_default(se_dump_stack*caller,T182 C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
T0* _v=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"all_default"" NATIVE_ARRAY[ACTEUR]",1,4,"%E182%upper%E2%Result%E6%i%E2%v%R60%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0862CC04/*l716c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0862D014/*l720c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862D50A/*l725c5/native_array.e*/;
R=((T6)(1));
ds.p=0x0862D60A/*l726c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862D80E/*l728c7/native_array.e*/;
tmp0/*or else*/=((T6)(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0862D826/*l728c19/native_array.e*/;
tmp0/*or else*/=((T6)(r6_px_not(&ds,(T6)(R))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0862DA0A/*l730c5/native_array.e*/;
_v=r182item(&ds,C,_i);
ds.p=0x0862DB10/*l731c8/native_array.e*/;
if((_v)!=((void*)((void*)0))){
ds.p=0x0862DC0C/*l732c6/native_array.e*/;
if((_v)==((void*)((void*)0))){
error1("Call on a Void target.",0x0862DC20/*l732c16/native_array.e*/);
}
if((((_v)->id))!=(INT8_C(60))){
error1("Bad target type. The expected type is ACTEUR.",0x0862DC20/*l732c16/native_array.e*/);
}
R=((T6)(r60is_default(&ds,((T60*)_v))));
}
ds.p=0x0862DE0A/*l734c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[ACTEUR]*/void r182clear_all(se_dump_stack*caller,T182 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" NATIVE_ARRAY[ACTEUR]",1,3,"%E182%upper%E2%v%R60%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08620A04/*l522c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08620D14/*l525c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862120A/*l530c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862140E/*l532c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0862160A/*l534c5/native_array.e*/;
r182put(&ds,C,_v,_i);
ds.p=0x0862170A/*l535c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08621A08/*l538c4/native_array.e*/;
ac_ens(r182all_default(&ds,C,a1),"all_default(upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[ACTEUR]*/void r182set_all_with(se_dump_stack*caller,T182 C,T0* a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"set_all_with"" NATIVE_ARRAY[ACTEUR]",1,3,"%E182%v%R60%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0861E704/*l487c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0861EA14/*l490c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0861EF0A/*l495c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0861F10E/*l497c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0861F30A/*l499c5/native_array.e*/;
r182put(&ds,C,a1,_i);
ds.p=0x0861F40A/*l500c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[ACTEUR]*/T182 r182realloc(se_dump_stack*caller,T182 C,T2 a1,T2 a2){
T182 R=(void*)0;
void**locals[3];
static se_frame_descriptor fd={"realloc"" NATIVE_ARRAY[ACTEUR]",1,3,"%E182%old_nb_elts%E2%new_nb_elts%E2%Result%E182%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08603904/*l57c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604008/*l64c4/native_array.e*/;
ac_req(r182is_not_null(&ds,C),"is_not_null");
ds.p=0x08604120/*l65c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"old_nb_elts > 0");
ds.p=0x08604220/*l66c16/native_array.e*/;
ac_req(r2_ix_60(&ds,a1,a2),"old_nb_elts < new_nb_elts");
fd.assertion_flag=1;
}
ds.p=0x08604408/*l68c4/native_array.e*/;
R=r182calloc(&ds,C,a2);
ds.p=0x08604516/*l69c11/native_array.e*/;
r182copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604716/*l71c11/native_array.e*/;
ac_ens(r182is_not_null(&ds,R),"Result.is_not_null");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[ACTEUR]*/void r182copy_from(se_dump_stack*caller,T182 C,T182 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from"" NATIVE_ARRAY[ACTEUR]",1,3,"%E182%model%E182%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08622F04/*l559c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08623214/*l562c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862370A/*l567c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0862390E/*l569c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x08623B0A/*l571c5/native_array.e*/;
r182put(&ds,C,r182item(&ds,a1,_i),_i);
ds.p=0x08623C0A/*l572c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[ACTEUR]*/T182 r182calloc(se_dump_stack*caller,T182 C,T2 a1){
T182 R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"calloc"" NATIVE_ARRAY[ACTEUR]",1,2,"%E182%nb_elements%E2%Result%E182%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08601B04/*l27c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08601F20/*l31c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"nb_elements > 0");
fd.assertion_flag=1;
}
R=new182(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602216/*l34c11/native_array.e*/;
ac_ens(r182all_default(&ds,R,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result.all_default(nb_elements - 1)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[AUTEUR]*/T0* r181item(se_dump_stack*caller,T181 C,T2 a1){
T0* R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"item"" NATIVE_ARRAY[AUTEUR]",1,2,"%E181%index%E2%Result%R56%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602504/*l37c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602914/*l41c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
R=(C)[a1];
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[AUTEUR]*/T6 r181is_not_null(se_dump_stack*caller,T181 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null"" NATIVE_ARRAY[AUTEUR]",1,1,"%E181%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08630504/*l773c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x08630708/*l775c4/native_array.e*/;
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[AUTEUR]*/void r181put(se_dump_stack*caller,T181 C,T0* a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" NATIVE_ARRAY[AUTEUR]",1,2,"%E181%element%R56%index%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602D04/*l45c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603214/*l50c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
(C)[a2]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603508/*l53c4/native_array.e*/;
ac_ens((r181item(&ds,C,a2))==((void*)(a1)),"item(index) = element");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[AUTEUR]*/T6 r181all_default(se_dump_stack*caller,T181 C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
T0* _v=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"all_default"" NATIVE_ARRAY[AUTEUR]",1,4,"%E181%upper%E2%Result%E6%i%E2%v%R56%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0862CC04/*l716c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0862D014/*l720c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862D50A/*l725c5/native_array.e*/;
R=((T6)(1));
ds.p=0x0862D60A/*l726c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862D80E/*l728c7/native_array.e*/;
tmp0/*or else*/=((T6)(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0862D826/*l728c19/native_array.e*/;
tmp0/*or else*/=((T6)(r6_px_not(&ds,(T6)(R))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0862DA0A/*l730c5/native_array.e*/;
_v=r181item(&ds,C,_i);
ds.p=0x0862DB10/*l731c8/native_array.e*/;
if((_v)!=((void*)((void*)0))){
ds.p=0x0862DC0C/*l732c6/native_array.e*/;
if((_v)==((void*)((void*)0))){
error1("Call on a Void target.",0x0862DC20/*l732c16/native_array.e*/);
}
if((((_v)->id))!=(INT8_C(56))){
error1("Bad target type. The expected type is AUTEUR.",0x0862DC20/*l732c16/native_array.e*/);
}
R=((T6)(r56is_default(&ds,((T56*)_v))));
}
ds.p=0x0862DE0A/*l734c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[AUTEUR]*/void r181clear_all(se_dump_stack*caller,T181 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" NATIVE_ARRAY[AUTEUR]",1,3,"%E181%upper%E2%v%R56%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08620A04/*l522c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08620D14/*l525c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862120A/*l530c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862140E/*l532c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0862160A/*l534c5/native_array.e*/;
r181put(&ds,C,_v,_i);
ds.p=0x0862170A/*l535c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08621A08/*l538c4/native_array.e*/;
ac_ens(r181all_default(&ds,C,a1),"all_default(upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[AUTEUR]*/void r181set_all_with(se_dump_stack*caller,T181 C,T0* a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"set_all_with"" NATIVE_ARRAY[AUTEUR]",1,3,"%E181%v%R56%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0861E704/*l487c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0861EA14/*l490c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0861EF0A/*l495c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0861F10E/*l497c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0861F30A/*l499c5/native_array.e*/;
r181put(&ds,C,a1,_i);
ds.p=0x0861F40A/*l500c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[AUTEUR]*/T181 r181realloc(se_dump_stack*caller,T181 C,T2 a1,T2 a2){
T181 R=(void*)0;
void**locals[3];
static se_frame_descriptor fd={"realloc"" NATIVE_ARRAY[AUTEUR]",1,3,"%E181%old_nb_elts%E2%new_nb_elts%E2%Result%E181%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08603904/*l57c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604008/*l64c4/native_array.e*/;
ac_req(r181is_not_null(&ds,C),"is_not_null");
ds.p=0x08604120/*l65c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"old_nb_elts > 0");
ds.p=0x08604220/*l66c16/native_array.e*/;
ac_req(r2_ix_60(&ds,a1,a2),"old_nb_elts < new_nb_elts");
fd.assertion_flag=1;
}
ds.p=0x08604408/*l68c4/native_array.e*/;
R=r181calloc(&ds,C,a2);
ds.p=0x08604516/*l69c11/native_array.e*/;
r181copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604716/*l71c11/native_array.e*/;
ac_ens(r181is_not_null(&ds,R),"Result.is_not_null");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[AUTEUR]*/void r181copy_from(se_dump_stack*caller,T181 C,T181 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from"" NATIVE_ARRAY[AUTEUR]",1,3,"%E181%model%E181%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08622F04/*l559c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08623214/*l562c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862370A/*l567c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0862390E/*l569c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x08623B0A/*l571c5/native_array.e*/;
r181put(&ds,C,r181item(&ds,a1,_i),_i);
ds.p=0x08623C0A/*l572c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[AUTEUR]*/T181 r181calloc(se_dump_stack*caller,T181 C,T2 a1){
T181 R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"calloc"" NATIVE_ARRAY[AUTEUR]",1,2,"%E181%nb_elements%E2%Result%E181%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08601B04/*l27c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08601F20/*l31c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"nb_elements > 0");
fd.assertion_flag=1;
}
R=new181(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602216/*l34c11/native_array.e*/;
ac_ens(r181all_default(&ds,R,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result.all_default(nb_elements - 1)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[REALISATEUR]*/T0* r180item(se_dump_stack*caller,T180 C,T2 a1){
T0* R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"item"" NATIVE_ARRAY[REALISATEUR]",1,2,"%E180%index%E2%Result%R59%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602504/*l37c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602914/*l41c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
R=(C)[a1];
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[REALISATEUR]*/T6 r180is_not_null(se_dump_stack*caller,T180 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null"" NATIVE_ARRAY[REALISATEUR]",1,1,"%E180%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08630504/*l773c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x08630708/*l775c4/native_array.e*/;
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[REALISATEUR]*/void r180put(se_dump_stack*caller,T180 C,T0* a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" NATIVE_ARRAY[REALISATEUR]",1,2,"%E180%element%R59%index%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602D04/*l45c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603214/*l50c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
(C)[a2]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603508/*l53c4/native_array.e*/;
ac_ens((r180item(&ds,C,a2))==((void*)(a1)),"item(index) = element");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[REALISATEUR]*/T6 r180all_default(se_dump_stack*caller,T180 C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
T0* _v=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"all_default"" NATIVE_ARRAY[REALISATEUR]",1,4,"%E180%upper%E2%Result%E6%i%E2%v%R59%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0862CC04/*l716c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0862D014/*l720c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862D50A/*l725c5/native_array.e*/;
R=((T6)(1));
ds.p=0x0862D60A/*l726c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862D80E/*l728c7/native_array.e*/;
tmp0/*or else*/=((T6)(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0862D826/*l728c19/native_array.e*/;
tmp0/*or else*/=((T6)(r6_px_not(&ds,(T6)(R))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0862DA0A/*l730c5/native_array.e*/;
_v=r180item(&ds,C,_i);
ds.p=0x0862DB10/*l731c8/native_array.e*/;
if((_v)!=((void*)((void*)0))){
ds.p=0x0862DC0C/*l732c6/native_array.e*/;
if((_v)==((void*)((void*)0))){
error1("Call on a Void target.",0x0862DC20/*l732c16/native_array.e*/);
}
if((((_v)->id))!=(INT8_C(59))){
error1("Bad target type. The expected type is REALISATEUR.",0x0862DC20/*l732c16/native_array.e*/);
}
R=((T6)(r59is_default(&ds,((T59*)_v))));
}
ds.p=0x0862DE0A/*l734c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[REALISATEUR]*/void r180clear_all(se_dump_stack*caller,T180 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" NATIVE_ARRAY[REALISATEUR]",1,3,"%E180%upper%E2%v%R59%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08620A04/*l522c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08620D14/*l525c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862120A/*l530c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862140E/*l532c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0862160A/*l534c5/native_array.e*/;
r180put(&ds,C,_v,_i);
ds.p=0x0862170A/*l535c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08621A08/*l538c4/native_array.e*/;
ac_ens(r180all_default(&ds,C,a1),"all_default(upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[REALISATEUR]*/void r180set_all_with(se_dump_stack*caller,T180 C,T0* a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"set_all_with"" NATIVE_ARRAY[REALISATEUR]",1,3,"%E180%v%R59%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0861E704/*l487c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0861EA14/*l490c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0861EF0A/*l495c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0861F10E/*l497c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0861F30A/*l499c5/native_array.e*/;
r180put(&ds,C,a1,_i);
ds.p=0x0861F40A/*l500c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[REALISATEUR]*/T180 r180realloc(se_dump_stack*caller,T180 C,T2 a1,T2 a2){
T180 R=(void*)0;
void**locals[3];
static se_frame_descriptor fd={"realloc"" NATIVE_ARRAY[REALISATEUR]",1,3,"%E180%old_nb_elts%E2%new_nb_elts%E2%Result%E180%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08603904/*l57c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604008/*l64c4/native_array.e*/;
ac_req(r180is_not_null(&ds,C),"is_not_null");
ds.p=0x08604120/*l65c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"old_nb_elts > 0");
ds.p=0x08604220/*l66c16/native_array.e*/;
ac_req(r2_ix_60(&ds,a1,a2),"old_nb_elts < new_nb_elts");
fd.assertion_flag=1;
}
ds.p=0x08604408/*l68c4/native_array.e*/;
R=r180calloc(&ds,C,a2);
ds.p=0x08604516/*l69c11/native_array.e*/;
r180copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604716/*l71c11/native_array.e*/;
ac_ens(r180is_not_null(&ds,R),"Result.is_not_null");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[REALISATEUR]*/void r180copy_from(se_dump_stack*caller,T180 C,T180 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from"" NATIVE_ARRAY[REALISATEUR]",1,3,"%E180%model%E180%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08622F04/*l559c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08623214/*l562c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862370A/*l567c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0862390E/*l569c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x08623B0A/*l571c5/native_array.e*/;
r180put(&ds,C,r180item(&ds,a1,_i),_i);
ds.p=0x08623C0A/*l572c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[REALISATEUR]*/T180 r180calloc(se_dump_stack*caller,T180 C,T2 a1){
T180 R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"calloc"" NATIVE_ARRAY[REALISATEUR]",1,2,"%E180%nb_elements%E2%Result%E180%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08601B04/*l27c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08601F20/*l31c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"nb_elements > 0");
fd.assertion_flag=1;
}
R=new180(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602216/*l34c11/native_array.e*/;
ac_ens(r180all_default(&ds,R,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result.all_default(nb_elements - 1)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[LIVRE]*/T0* r183item(se_dump_stack*caller,T183 C,T2 a1){
T0* R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"item"" NATIVE_ARRAY[LIVRE]",1,2,"%E183%index%E2%Result%R50%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602504/*l37c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602914/*l41c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
R=(C)[a1];
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[LIVRE]*/T6 r183is_not_null(se_dump_stack*caller,T183 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null"" NATIVE_ARRAY[LIVRE]",1,1,"%E183%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08630504/*l773c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x08630708/*l775c4/native_array.e*/;
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[LIVRE]*/void r183put(se_dump_stack*caller,T183 C,T0* a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" NATIVE_ARRAY[LIVRE]",1,2,"%E183%element%R50%index%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602D04/*l45c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603214/*l50c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
(C)[a2]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603508/*l53c4/native_array.e*/;
ac_ens((r183item(&ds,C,a2))==((void*)(a1)),"item(index) = element");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[LIVRE]*/T6 r183all_default(se_dump_stack*caller,T183 C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
T0* _v=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"all_default"" NATIVE_ARRAY[LIVRE]",1,4,"%E183%upper%E2%Result%E6%i%E2%v%R50%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0862CC04/*l716c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0862D014/*l720c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862D50A/*l725c5/native_array.e*/;
R=((T6)(1));
ds.p=0x0862D60A/*l726c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862D80E/*l728c7/native_array.e*/;
tmp0/*or else*/=((T6)(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0862D826/*l728c19/native_array.e*/;
tmp0/*or else*/=((T6)(r6_px_not(&ds,(T6)(R))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0862DA0A/*l730c5/native_array.e*/;
_v=r183item(&ds,C,_i);
ds.p=0x0862DB10/*l731c8/native_array.e*/;
if((_v)!=((void*)((void*)0))){
ds.p=0x0862DC0C/*l732c6/native_array.e*/;
if((_v)==((void*)((void*)0))){
error1("Call on a Void target.",0x0862DC20/*l732c16/native_array.e*/);
}
if((((_v)->id))!=(INT8_C(50))){
error1("Bad target type. The expected type is LIVRE.",0x0862DC20/*l732c16/native_array.e*/);
}
R=((T6)(r50is_default(&ds,((T50*)_v))));
}
ds.p=0x0862DE0A/*l734c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[LIVRE]*/void r183clear_all(se_dump_stack*caller,T183 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" NATIVE_ARRAY[LIVRE]",1,3,"%E183%upper%E2%v%R50%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08620A04/*l522c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08620D14/*l525c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862120A/*l530c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862140E/*l532c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0862160A/*l534c5/native_array.e*/;
r183put(&ds,C,_v,_i);
ds.p=0x0862170A/*l535c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08621A08/*l538c4/native_array.e*/;
ac_ens(r183all_default(&ds,C,a1),"all_default(upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[LIVRE]*/void r183set_all_with(se_dump_stack*caller,T183 C,T0* a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"set_all_with"" NATIVE_ARRAY[LIVRE]",1,3,"%E183%v%R50%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0861E704/*l487c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0861EA14/*l490c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0861EF0A/*l495c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0861F10E/*l497c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0861F30A/*l499c5/native_array.e*/;
r183put(&ds,C,a1,_i);
ds.p=0x0861F40A/*l500c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[LIVRE]*/T183 r183realloc(se_dump_stack*caller,T183 C,T2 a1,T2 a2){
T183 R=(void*)0;
void**locals[3];
static se_frame_descriptor fd={"realloc"" NATIVE_ARRAY[LIVRE]",1,3,"%E183%old_nb_elts%E2%new_nb_elts%E2%Result%E183%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08603904/*l57c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604008/*l64c4/native_array.e*/;
ac_req(r183is_not_null(&ds,C),"is_not_null");
ds.p=0x08604120/*l65c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"old_nb_elts > 0");
ds.p=0x08604220/*l66c16/native_array.e*/;
ac_req(r2_ix_60(&ds,a1,a2),"old_nb_elts < new_nb_elts");
fd.assertion_flag=1;
}
ds.p=0x08604408/*l68c4/native_array.e*/;
R=r183calloc(&ds,C,a2);
ds.p=0x08604516/*l69c11/native_array.e*/;
r183copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604716/*l71c11/native_array.e*/;
ac_ens(r183is_not_null(&ds,R),"Result.is_not_null");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[LIVRE]*/void r183copy_from(se_dump_stack*caller,T183 C,T183 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from"" NATIVE_ARRAY[LIVRE]",1,3,"%E183%model%E183%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08622F04/*l559c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08623214/*l562c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862370A/*l567c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0862390E/*l569c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x08623B0A/*l571c5/native_array.e*/;
r183put(&ds,C,r183item(&ds,a1,_i),_i);
ds.p=0x08623C0A/*l572c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[LIVRE]*/T183 r183calloc(se_dump_stack*caller,T183 C,T2 a1){
T183 R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"calloc"" NATIVE_ARRAY[LIVRE]",1,2,"%E183%nb_elements%E2%Result%E183%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08601B04/*l27c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08601F20/*l31c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"nb_elements > 0");
fd.assertion_flag=1;
}
R=new183(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602216/*l34c11/native_array.e*/;
ac_ens(r183all_default(&ds,R,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result.all_default(nb_elements - 1)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[DVD]*/T0* r179item(se_dump_stack*caller,T179 C,T2 a1){
T0* R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"item"" NATIVE_ARRAY[DVD]",1,2,"%E179%index%E2%Result%R58%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602504/*l37c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602914/*l41c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
R=(C)[a1];
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[DVD]*/T6 r179is_not_null(se_dump_stack*caller,T179 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null"" NATIVE_ARRAY[DVD]",1,1,"%E179%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08630504/*l773c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x08630708/*l775c4/native_array.e*/;
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[DVD]*/void r179put(se_dump_stack*caller,T179 C,T0* a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" NATIVE_ARRAY[DVD]",1,2,"%E179%element%R58%index%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602D04/*l45c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603214/*l50c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
(C)[a2]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603508/*l53c4/native_array.e*/;
ac_ens((r179item(&ds,C,a2))==((void*)(a1)),"item(index) = element");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[DVD]*/T6 r179all_default(se_dump_stack*caller,T179 C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
T0* _v=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"all_default"" NATIVE_ARRAY[DVD]",1,4,"%E179%upper%E2%Result%E6%i%E2%v%R58%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0862CC04/*l716c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0862D014/*l720c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862D50A/*l725c5/native_array.e*/;
R=((T6)(1));
ds.p=0x0862D60A/*l726c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862D80E/*l728c7/native_array.e*/;
tmp0/*or else*/=((T6)(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0862D826/*l728c19/native_array.e*/;
tmp0/*or else*/=((T6)(r6_px_not(&ds,(T6)(R))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0862DA0A/*l730c5/native_array.e*/;
_v=r179item(&ds,C,_i);
ds.p=0x0862DB10/*l731c8/native_array.e*/;
if((_v)!=((void*)((void*)0))){
ds.p=0x0862DC0C/*l732c6/native_array.e*/;
if((_v)==((void*)((void*)0))){
error1("Call on a Void target.",0x0862DC20/*l732c16/native_array.e*/);
}
if((((_v)->id))!=(INT8_C(58))){
error1("Bad target type. The expected type is DVD.",0x0862DC20/*l732c16/native_array.e*/);
}
R=((T6)(r58is_default(&ds,((T58*)_v))));
}
ds.p=0x0862DE0A/*l734c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[DVD]*/void r179clear_all(se_dump_stack*caller,T179 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" NATIVE_ARRAY[DVD]",1,3,"%E179%upper%E2%v%R58%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08620A04/*l522c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08620D14/*l525c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862120A/*l530c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862140E/*l532c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0862160A/*l534c5/native_array.e*/;
r179put(&ds,C,_v,_i);
ds.p=0x0862170A/*l535c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08621A08/*l538c4/native_array.e*/;
ac_ens(r179all_default(&ds,C,a1),"all_default(upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[DVD]*/void r179set_all_with(se_dump_stack*caller,T179 C,T0* a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"set_all_with"" NATIVE_ARRAY[DVD]",1,3,"%E179%v%R58%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0861E704/*l487c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0861EA14/*l490c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0861EF0A/*l495c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0861F10E/*l497c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0861F30A/*l499c5/native_array.e*/;
r179put(&ds,C,a1,_i);
ds.p=0x0861F40A/*l500c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[DVD]*/T179 r179realloc(se_dump_stack*caller,T179 C,T2 a1,T2 a2){
T179 R=(void*)0;
void**locals[3];
static se_frame_descriptor fd={"realloc"" NATIVE_ARRAY[DVD]",1,3,"%E179%old_nb_elts%E2%new_nb_elts%E2%Result%E179%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08603904/*l57c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604008/*l64c4/native_array.e*/;
ac_req(r179is_not_null(&ds,C),"is_not_null");
ds.p=0x08604120/*l65c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"old_nb_elts > 0");
ds.p=0x08604220/*l66c16/native_array.e*/;
ac_req(r2_ix_60(&ds,a1,a2),"old_nb_elts < new_nb_elts");
fd.assertion_flag=1;
}
ds.p=0x08604408/*l68c4/native_array.e*/;
R=r179calloc(&ds,C,a2);
ds.p=0x08604516/*l69c11/native_array.e*/;
r179copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604716/*l71c11/native_array.e*/;
ac_ens(r179is_not_null(&ds,R),"Result.is_not_null");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[DVD]*/void r179copy_from(se_dump_stack*caller,T179 C,T179 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from"" NATIVE_ARRAY[DVD]",1,3,"%E179%model%E179%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08622F04/*l559c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08623214/*l562c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862370A/*l567c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0862390E/*l569c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x08623B0A/*l571c5/native_array.e*/;
r179put(&ds,C,r179item(&ds,a1,_i),_i);
ds.p=0x08623C0A/*l572c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[DVD]*/T179 r179calloc(se_dump_stack*caller,T179 C,T2 a1){
T179 R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"calloc"" NATIVE_ARRAY[DVD]",1,2,"%E179%nb_elements%E2%Result%E179%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08601B04/*l27c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08601F20/*l31c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"nb_elements > 0");
fd.assertion_flag=1;
}
R=new179(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602216/*l34c11/native_array.e*/;
ac_ens(r179all_default(&ds,R,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result.all_default(nb_elements - 1)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[MEDIA]*/T0* r178item(se_dump_stack*caller,T178 C,T2 a1){
T0* R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"item"" NATIVE_ARRAY[MEDIA]",1,2,"%E178%index%E2%Result%R51%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602504/*l37c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602914/*l41c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
R=(C)[a1];
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[MEDIA]*/T6 r178is_not_null(se_dump_stack*caller,T178 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null"" NATIVE_ARRAY[MEDIA]",1,1,"%E178%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08630504/*l773c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x08630708/*l775c4/native_array.e*/;
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[MEDIA]*/void r178put(se_dump_stack*caller,T178 C,T0* a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" NATIVE_ARRAY[MEDIA]",1,2,"%E178%element%R51%index%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08602D04/*l45c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603214/*l50c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
(C)[a2]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08603508/*l53c4/native_array.e*/;
ac_ens((r178item(&ds,C,a2))==((void*)(a1)),"item(index) = element");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[MEDIA]*/T6 r178all_default(se_dump_stack*caller,T178 C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
T6 tmp1;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
T0* _v=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"all_default"" NATIVE_ARRAY[MEDIA]",1,4,"%E178%upper%E2%Result%E6%i%E2%v%R51%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0862CC04/*l716c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0862D014/*l720c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862D50A/*l725c5/native_array.e*/;
R=((T6)(1));
ds.p=0x0862D60A/*l726c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862D80E/*l728c7/native_array.e*/;
tmp0/*or else*/=((T6)(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0862D826/*l728c19/native_array.e*/;
tmp0/*or else*/=((T6)(r6_px_not(&ds,(T6)(R))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0862DA0A/*l730c5/native_array.e*/;
_v=r178item(&ds,C,_i);
ds.p=0x0862DB10/*l731c8/native_array.e*/;
if((_v)!=((void*)((void*)0))){
ds.p=0x0862DC0C/*l732c6/native_array.e*/;
if((_v)==((void*)((void*)0))){
error1("Call on a Void target.",0x0862DC20/*l732c16/native_array.e*/);
}
/*[inspectDynamicDispatch*/
switch(((_v)->id)){
case 58:
tmp1/*is_default*/=((T6)(r58is_default(&ds,((T58*)_v))));
break;
case 50:
tmp1/*is_default*/=((T6)(r50is_default(&ds,((T50*)_v))));
break;
default:;
error1("Invalid type for the target of this function call.",0x0862DC24/*l732c18/native_array.e*/);
}
/*inspect]*/
R=((T6)(tmp1/*is_default*/));
}
ds.p=0x0862DE0A/*l734c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[MEDIA]*/void r178clear_all(se_dump_stack*caller,T178 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" NATIVE_ARRAY[MEDIA]",1,3,"%E178%upper%E2%v%R51%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08620A04/*l522c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08620D14/*l525c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862120A/*l530c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x0862140E/*l532c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0862160A/*l534c5/native_array.e*/;
r178put(&ds,C,_v,_i);
ds.p=0x0862170A/*l535c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08621A08/*l538c4/native_array.e*/;
ac_ens(r178all_default(&ds,C,a1),"all_default(upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[MEDIA]*/void r178set_all_with(se_dump_stack*caller,T178 C,T0* a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"set_all_with"" NATIVE_ARRAY[MEDIA]",1,3,"%E178%v%R51%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0861E704/*l487c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0861EA14/*l490c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0861EF0A/*l495c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0861F10E/*l497c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0861F30A/*l499c5/native_array.e*/;
r178put(&ds,C,a1,_i);
ds.p=0x0861F40A/*l500c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[MEDIA]*/T178 r178realloc(se_dump_stack*caller,T178 C,T2 a1,T2 a2){
T178 R=(void*)0;
void**locals[3];
static se_frame_descriptor fd={"realloc"" NATIVE_ARRAY[MEDIA]",1,3,"%E178%old_nb_elts%E2%new_nb_elts%E2%Result%E178%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08603904/*l57c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604008/*l64c4/native_array.e*/;
ac_req(r178is_not_null(&ds,C),"is_not_null");
ds.p=0x08604120/*l65c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"old_nb_elts > 0");
ds.p=0x08604220/*l66c16/native_array.e*/;
ac_req(r2_ix_60(&ds,a1,a2),"old_nb_elts < new_nb_elts");
fd.assertion_flag=1;
}
ds.p=0x08604408/*l68c4/native_array.e*/;
R=r178calloc(&ds,C,a2);
ds.p=0x08604516/*l69c11/native_array.e*/;
r178copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08604716/*l71c11/native_array.e*/;
ac_ens(r178is_not_null(&ds,R),"Result.is_not_null");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[MEDIA]*/void r178copy_from(se_dump_stack*caller,T178 C,T178 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from"" NATIVE_ARRAY[MEDIA]",1,3,"%E178%model%E178%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08622F04/*l559c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08623214/*l562c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x0862370A/*l567c5/native_array.e*/;
_i=a2;
while(1){
ds.p=0x0862390E/*l569c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x08623B0A/*l571c5/native_array.e*/;
r178put(&ds,C,r178item(&ds,a1,_i),_i);
ds.p=0x08623C0A/*l572c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[MEDIA]*/T178 r178calloc(se_dump_stack*caller,T178 C,T2 a1){
T178 R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"calloc"" NATIVE_ARRAY[MEDIA]",1,2,"%E178%nb_elements%E2%Result%E178%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08601B04/*l27c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08601F20/*l31c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"nb_elements > 0");
fd.assertion_flag=1;
}
R=new178(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08602216/*l34c11/native_array.e*/;
ac_ens(r178all_default(&ds,R,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result.all_default(nb_elements - 1)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

#ifdef __cplusplus
}
#endif
