#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.4 (svn snaphsot 9308) [????]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of
  compilation: -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/

#ifndef _BASE_H
#define _BASE_H

#if defined(_MSC_VER) && (_MSC_VER >= 1400)       /* VC8+ */
# ifndef _CRT_SECURE_NO_DEPRECATE
#  define _CRT_SECURE_NO_DEPRECATE
# endif
# ifndef _CRT_NONSTDC_NO_DEPRECATE
#  define _CRT_NONSTDC_NO_DEPRECATE
# endif
#endif   /* VC8+ */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  include <unistd.h>
#endif
#if !defined(WIN32) && \
       (defined(WINVER) || defined(_WIN32_WINNT) || defined(_WIN32) || \
	defined(__WIN32__) || defined(__TOS_WIN__) || defined(_MSC_VER))
#  define WIN32 1
#endif
#ifdef WIN32
#  include <windows.h>
#else
#  ifndef O_RDONLY
#    include <sys/file.h>
#  endif
#  ifndef O_RDONLY
#    define O_RDONLY 0000
#  endif
#endif

#if defined(_MSC_VER) && (_MSC_VER < 1600) /* MSVC older than v10 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "I64d"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c
#  define INT64_C(c) c ## i64
#elif defined(__WATCOMC__) && (__WATCOMC__ <= 1220) /* WATCOM 12.2 or lower */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__BORLANDC__) && (__BORLANDC__ < 0x600) /* Borland before 6.0 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "I64Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__FreeBSD__) && (__FreeBSD__ < 5) /* FreeBSD before 5.0 */ && !defined (_SYS_INTTYPES_H_)
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#elif defined(__CYGWIN__) && defined(__BIT_TYPES_DEFINED__) /* Cygwin defines intxx_t in sys/types.h instead of inttypes.h */
#  include <cygwin/version.h>
#  if defined(CYGWIN_VERSION_DLL_MAJOR) && (CYGWIN_VERSION_DLL_MAJOR<1005)
typedef unsigned char uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
#  endif
#elif defined(SASC)
#    error("Too old SAS/C compiler, sorry.");
#elif defined(__SASC__)
#  if (__SASC__ < 750 ) /*  SAS/C before 7.50 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#  endif
#else
#  include <inttypes.h>
#  if !defined(INT8_MAX) && defined(INT16_MAX)
/* int8_t is not mandatory */
typedef int_least8_t int8_t;
#  endif
#endif

#if !defined(PRId16)
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "lld"
#elif !defined(PRId8)
#  define PRId8 "d"
#endif
#if !defined(INT16_C)
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## LL
#elif !defined(INT8_C)
#  define INT8_C(c) c
#endif
#if !defined(INT16_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#  define INT8_MAX (INT8_C(127))
#  define INT16_MIN (-INT16_C(32767)-1)
#  define INT16_MAX (INT16_C(32767))
#  define INT32_MIN (-INT32_C(2147483647)-1)
#  define INT32_MAX (INT32_C(2147483647))
#  define INT64_MIN (-INT64_C(9223372036854775807)-1)
#  define INT64_MAX (INT64_C(9223372036854775807))
#elif !defined(INT8_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#endif


/*
  Endian stuff
*/
#if defined(BSD) && (BSD >= 199103)
#  include <machine/endian.h>
#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
/* bi-endian processor, current mode should be find in machine/endian.h file */
#  include <machine/endian.h>
#elif defined(linux)
#  include <endian.h>
#endif



#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)
#  define BYTE_ORDER      __BYTE_ORDER
#endif

#if !defined(LITTLE_ENDIAN) && defined(__LITTLE_ENDIAN)
#  define LITTLE_ENDIAN      __LITTLE_ENDIAN
#endif

#if !defined(BIG_ENDIAN) && defined(__BIG_ENDIAN)
#  define BIG_ENDIAN      __BIG_ENDIAN
#endif

#if !defined(LITTLE_ENDIAN)
#  define LITTLE_ENDIAN   1234    /* LSB first (vax, pc) */
#endif
#if !defined(BIG_ENDIAN)
#  define BIG_ENDIAN      4321    /* MSB first (IBM, net) */
#endif
#if !defined(PDP_ENDIAN)
#  define PDP_ENDIAN      3412    /* LSB first in word, MSW first in long */
#endif

#if !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_RIGHT)
#  define BYTE_ORDER      LITTLE_ENDIAN
#elif !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_LEFT)
#  define BYTE_ORDER      BIG_ENDIAN
#elif !defined(BYTE_ORDER)

/* ARM */
#  if defined(__ARMEL__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(__ARMEB__)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__arm__)
#    error "ARMs are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* HP RISC */
#  if defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* IBM */
#  if defined(ibm032) || defined(ibm370) || defined(_IBMR2) || \
      defined(IBM370) || defined(__MVS__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Intel x86 */
#  if defined(i386) || defined(__i386__) || defined(__i386) || \
      defined(_M_IX86) || defined(_X86_) || defined(__THW_INTEL) || \
      defined(sun386)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Intel Itanium */
#  if defined(__ia64__) || defined(_IA64) || defined(__IA64__) || \
      defined(_M_IA64)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Nationnal Semiconductor 32000 serie */
#  if  defined(ns32000)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Motorola 68000 */
#  if defined(mc68000) || defined(is68k) || defined(macII) || defined(m68k)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* MIPS */
#  if defined(MIPSEL) || defined(_MIPSEL)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(MIPSEB) || defined(_MIPSEB)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__mips__) || defined(__mips) || defined(__MIPS__)
#    error "MIPS are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* Power PC */
/* this processor is bi-endian, how to know if little-endian is set? */
#  if defined(__powerpc) || defined(__powerpc__) || defined(__POWERPC__) || \
      defined(__ppc__) || defined(__ppc) || defined(_M_PPC) || \
      defined(__PPC) || defined(__PPC__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Pyramid 9810 */
#  if defined(pyr)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* RS/6000 */
#  if defined(__THW_RS6000) || defined(_IBMR2) || defined(_POWER) || \
      defined(_ARCH_PWR) || defined(_ARCH_PWR2)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* SPARC */
#  if defined(__sparc__) || defined(sparc) || defined(__sparc)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* CCI Tahoe */
#  if defined(tahoe)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* VAX */
#  if defined(vax) || defined(VAX) || defined(__vax__) || defined(_vax_) || \
      defined(__vax) || defined(__VAX)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* ELATE is a virtual OS with a little endian Virtual Processor */
#  if defined(__ELATE__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous little endian */
#  if defined(wrltitan)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous big endian */
#  if defined(apollo) || defined(__convex__) || defined(_CRAY) || defined(sel)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif
#endif


#if !defined(BYTE_ORDER)
#  error "Unknown byte order. Add your system in above macros once you know your system type. Please drop an e-mail to SmartEiffel@loria.fr"
#endif
#if (BYTE_ORDER != BIG_ENDIAN && BYTE_ORDER != LITTLE_ENDIAN)
#  error "Only little-endian and big-endian are valid at this time. Please drop an e-mail to SmartEiffel@loria.fr"
#endif


/*
  Byte swapping stuff
*/
extern void copy_swap_16(const uint16_t *src, uint16_t *dest, int count);


/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#  define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#  define EXIT_SUCCESS 0
#endif

/*
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.

   NOTE: with gcc, -ansi is used for SmartEiffel generated files EXCEPT in
   -no_split mode. ANSI only recognizes the non-sig versions.
*/
#if (defined(_SIGSET_H_types) && !defined(__STRICT_ANSI__))
#  define JMP_BUF    sigjmp_buf
#  define SETJMP(x)  sigsetjmp( (x), 1)
#  define LONGJMP    siglongjmp
#else
#  define JMP_BUF    jmp_buf
#  define SETJMP(x)  setjmp( (x) )
#  define LONGJMP    longjmp
#endif

/*
   Type to store reference objects Id:
 */
typedef int Tid;
typedef struct S0 T0;
struct S0{Tid id;};

/*
   The default channel used to print runtime error messages:
*/
#define SE_ERR stderr

/*
   Eiffel type INTEGER_8 is #1:
*/
typedef int8_t T1;
#define EIF_INTEGER_8 T1
#define M1 (INT8_C(0))
#define EIF_INTEGER_8_BITS (CHAR_BIT)
#define EIF_MINIMUM_INTEGER_8 (INT8_MIN)
#define EIF_MAXIMUM_INTEGER_8 (INT8_MAX)

/*
  Eiffel type INTEGER_16 is #10:
*/
typedef int16_t T10;
#define EIF_INTEGER_16 T10
#define M10 (INT16_C(0))
#define EIF_INTEGER_16_BITS (CHAR_BIT*sizeof(T10t))
#define EIF_MINIMUM_INTEGER_16 (INT16_MIN) /*-32768*/
#define EIF_MAXIMUM_INTEGER_16 (INT16_MAX) /*+32767*/

/*
  Eiffel type INTEGER or INTEGER_32 is #2:
*/
typedef int32_t T2;
#define EIF_INTEGER T2
#define EIF_INTEGER_32 T2
#define M2 (INT32_C(0))
#define EIF_INTEGER_BITS ((T2)(CHAR_BIT*sizeof(T2)))
#define EIF_INTEGER_32_BITS EIF_INTEGER_BITS
#define EIF_MINIMUM_INTEGER (INT32_MIN)
#define EIF_MAXIMUM_INTEGER (INT32_MAX)

/*
  Eiffel type INTEGER_64 is #11:
*/
typedef int64_t T11;
#define EIF_INTEGER_64 T11
#define M11 (INT64_C(0))
#define EIF_INTEGER_64_BITS (CHAR_BIT*sizeof(T11))
#define EIF_MINIMUM_INTEGER_64 (INT64_MIN)
#define EIF_MAXIMUM_INTEGER_64 (INT64_MAX)

/*
  Eiffel type CHARACTER is #3:
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T10)(x))
#define T3to_integer(x) ((signed char)(x))
#define T3to_integer_8(x) ((signed char)(x))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL_32 is #4:
*/
typedef float T4;
typedef T4 real32_t;
#define EIF_REAL_32 T4
#define M4 (0.0)
#define EIF_MINIMUM_REAL_32 (-(FLT_MAX))
#define EIF_MAXIMUM_REAL_32 (FLT_MAX)

/*
  Eiffel type REAL or REAL_64 is #5:
*/
typedef double T5;
typedef T5 real64_t;
#define EIF_REAL_64 T5
#define M5 (0.0)
#define EIF_MINIMUM_REAL_64 (-(DBL_MAX))
#define EIF_MINIMUM_REAL (EIF_MINIMUM_REAL_64)
#define EIF_MAXIMUM_REAL_64 (DBL_MAX)
#define EIF_MAXIMUM_REAL (EIF_MAXIMUM_REAL_64)

/*
  Eiffel type REAL_EXTENDED is #12:
*/
typedef long double T12;
typedef T12 real_extended_t;
#define EIF_REAL_EXTENDED T12
#define M12 (0.0)
#define EIF_MINIMUM_REAL_EXTENDED (-(DBL_MAX))
#define EIF_MAXIMUM_REAL_EXTENDED (DBL_MAX)

/*
  Eiffel type BOOLEAN is #6:
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/*
   Eiffel type POINTER is #8:
*/
typedef void* T8;
#define EIF_POINTER T8
/* Sometimes, NULL is defined as 0 */
#define M8 ((void*)NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side:
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL:
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ

/*
   Wrappers for `malloc' and `calloc':
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);
void* se_realloc(void* src, size_t size);

/*
   die method.
 */
void se_die(int code);

/*
    Runtime hooks. They allow different runtime modules to be quite independant. In time, they will also allow
    thread-safe operations.

    Currently known modules:
      - boost
      - no_check
      - sedb
      - gc
      - print stack
      - profile
      - plugins

    However, currently only profile uses this method. It will be extended to other modules later.

    The currently defined hooks are described in the enum below (the names should be self-explanatory).
 */
typedef enum {
  SE_HANDLE_EXCEPTION_SET, /* called when an exception handler is set, prior to SETJMP */
  SE_HANDLE_EXCEPTION_CLEAR, /* called when a feature with an exception handler normally returns */
  SE_HANDLE_EXCEPTION_THROWN, /* called when an exception is thrown, prior to the LONGJMP */
  SE_HANDLE_ENTER_GC, /* called when gc_start() begins */
  SE_HANDLE_EXIT_GC, /* called when gc_start() ends */
  SE_HANDLE_ENTER_PRINT_STACK, /* called when se_print_run_time_stack() begins */
  SE_HANDLE_EXIT_PRINT_STACK, /* called when se_print_run_time_stack() ends */
  SE_HANDLE_NO_MORE_MEMORY, /* called by se_alloc() and co */
  SE_HANDLE_SEDB_BREAK, /* called when sedb stops the program */
  SE_HANDLE_SEDB_CONTINUE, /* called when sedb continues the program */
  SE_HANDLE_RUNTIME_ERROR, /* called when a runtime error is raised and not caught by an exception. Cannot be raised in boost mode. */
  SE_HANDLE_DIE_WITH_CODE, /* called when the program is stopped by the die_with_code feature. The data points to the int code. */
  SE_HANDLE_NORMAL_EXIT /* called when the program correctly terminates. The data is null. */
} se_handler_action_t;

extern int handlers_count;
typedef void se_runtime_handler_t(se_handler_action_t action, void*data);
void register_handler(se_runtime_handler_t*handler);
void _handle(se_handler_action_t action, void*data);

#define handle(action,data) do{if(handlers_count>0)_handle(action,data);}while(0)

#endif /* #ifndef _BASE_H */
#define SE_GC_LIB 1
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#include <errno.h>

#define text_file_read_open(p) (fopen(((char*)(p)),"r"))
#define text_file_write_open(p) (fopen(((char*)(p)),"w"))
#define text_file_write_append(p) (fopen(((char*)(p)),"a"))
#define text_file_read_write_open(p) (fopen(((char*)(p)),"r+"))
#define text_file_read_write_append(p) (fopen(((char*)(p)),"a+"))
#define binary_file_read_open(p) (fopen(((char*)(p)),"rb"))
#define binary_file_write_open(p) (fopen(((char*)(p)),"wb"))
#define binary_file_write_append(p) (fopen(((char*)(p)),"ab"))
#define io_fclose(p) (fclose((FILE*)(p)))
#define io_flush(p) (fflush((FILE*)(p)))
#define io_getc(f) (getc(((FILE*)(f))))
#define io_putc(b, f) (putc((b),((FILE*)(f))))
#define io_ungetc(b, f) (ungetc((b), (FILE*)(f)))
#define io_fread(b, n, f) (fread((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_fwrite(b, n, f) (fwrite((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_feof(f) (feof(((FILE*)(f))))
#define io_rename(o, n) (rename(((char*)(o)),((char*)(n))))
#define io_remove(f) (remove(((char*)(f))))
#define io_fseek(f, o) (fseek((FILE*)(f),(o),SEEK_SET))
#define io_ftell(f) ((EIF_INTEGER_64)ftell((FILE*)(f)))

#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  define read_stdin(b, s) (read(STDIN_FILENO, b, s))
#else
   extern int read_stdin(EIF_CHARACTER *buffer, int size);
#endif

extern void io_copy(char*source, char*target);
extern int io_file_exists(char*source);
extern int io_same_physical_file(char*path1,char*path2);
/* C Header Pass 1: */
typedef struct S7 T7;
typedef struct S61 T61;
typedef struct S60 T60;
typedef struct S56 T56;
typedef struct S59 T59;
typedef struct S50 T50;
typedef struct S58 T58;
typedef struct S48 T48;
typedef struct S49 T49;
typedef struct S177 T177;
typedef struct S64 T64;
typedef struct S176 T176;
typedef struct S174 T174;
typedef struct S173 T173;
typedef struct S172 T172;
typedef struct S175 T175;
typedef struct S171 T171;
typedef struct S170 T170;
typedef struct S41 T41;
typedef struct S25 T25;
/* C Header Pass 2: */
typedef T0**T185;
#define M185 NULL
typedef T0**T184;
#define M184 NULL
typedef T0**T182;
#define M182 NULL
typedef T0**T181;
#define M181 NULL
typedef T0**T180;
#define M180 NULL
typedef T0**T183;
#define M183 NULL
typedef T0**T179;
#define M179 NULL
typedef T0**T178;
#define M178 NULL
typedef T3*T9;
#define M9 NULL
/* C Header Pass 3: */
/* C Header Pass 4: */
void se_prinT185(FILE* file,T185*o);
void se_prinT184(FILE* file,T184*o);
void se_prinT182(FILE* file,T182*o);
void se_prinT181(FILE* file,T181*o);
void se_prinT180(FILE* file,T180*o);
void se_prinT183(FILE* file,T183*o);
void se_prinT179(FILE* file,T179*o);
void se_prinT178(FILE* file,T178*o);
struct S48{Tid id;T0* _filter;T2 _buffer_position;T9 _buffer;T2 _capacity;};
extern T48 M48;
void se_prinT48(FILE* file,T48**o);
struct S49{Tid id;T0* _filter;T6 _end_of_input;T3 _filtered_last_character;T9 _buffer;T6 _end_reached;T2 _buffer_size;T2 _buffer_position;T2 _capacity;T6 _unread_character_flag;};
extern T49 M49;
void se_prinT49(FILE* file,T49**o);
struct S177{Tid id;T185 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T177 M177;
void se_prinT177(FILE* file,T177**o);
struct S64{Tid id;T0* _filter;T0* _path;T6 _end_of_input;T3 _filtered_last_character;T8 _input_stream;T9 _buffer;T6 _end_reached;T2 _buffer_size;T2 _buffer_position;T2 _capacity;};
extern T64 M64;
void se_prinT64(FILE* file,T64**o);
struct S176{Tid id;T184 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T176 M176;
void se_prinT176(FILE* file,T176**o);
struct S60{Tid id;T0* _nom;T0* _prenom;T0* _lst_films;};
extern T60 M60;
void se_prinT60(FILE* file,T60**o);
struct S174{Tid id;T182 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T174 M174;
void se_prinT174(FILE* file,T174**o);
struct S56{Tid id;T0* _nom;T0* _prenom;T0* _lst_livres;};
extern T56 M56;
void se_prinT56(FILE* file,T56**o);
struct S173{Tid id;T181 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T173 M173;
void se_prinT173(FILE* file,T173**o);
struct S59{Tid id;T0* _nom;T0* _prenom;T0* _lst_films;};
extern T59 M59;
void se_prinT59(FILE* file,T59**o);
struct S172{Tid id;T180 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T172 M172;
void se_prinT172(FILE* file,T172**o);
struct S50{Tid id;T0* _titre;T2 _nombre_exemplaires;T0* _auteur;};
extern T50 M50;
void se_prinT50(FILE* file,T50**o);
struct S175{Tid id;T183 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T175 M175;
void se_prinT175(FILE* file,T175**o);
struct S58{Tid id;T0* _titre;T2 _nombre_exemplaires;T2 _annee;T0* _type;T0* _lst_acteurs;T0* _lst_realisateurs;};
extern T58 M58;
void se_prinT58(FILE* file,T58**o);
struct S171{Tid id;T179 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T171 M171;
void se_prinT171(FILE* file,T171**o);
struct S170{Tid id;T178 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T170 M170;
void se_prinT170(FILE* file,T170**o);
struct S61{Tid id;T0* _nom;T0* _prenom;T0* _identifiant;T6 _admin;};
extern T61 M61;
void se_prinT61(FILE* file,T61**o);
struct S41{Tid id;T0* _filter;T0* _output_filter;T0* _input_filter;};
extern T41 M41;
void se_prinT41(FILE* file,T41**o);
struct S25{Tid id;T0* _lst_users;T0* _lst_acteurs;T0* _lst_realisateurs;T0* _lst_auteurs;T0* _lst_livres;T0* _lst_dvd;T0* _lst_media_choisis;T0* _utilisateur_connecte;};
extern T25 M25;
void se_prinT25(FILE* file,T25**o);
void se_prinT9(FILE* file,T9*o);
struct S7{Tid id;T9 _storage;T2 _count;T2 _capacity;};
extern T7 M7;
extern char*s25_0;
extern char*s25_10;
extern char*s25_1502332569;
extern char*s62_117797837;
extern char*s25_47;
extern char*s25_62;
extern char*s25_78;
extern char*s25_79;
extern char*s61_125;
extern char*s59_204;
extern char*s25_234255023;
extern char*s25_1987806774;
extern char*s25_498422136;
extern char*s61_56097703;
extern char*s25_846833530;
extern char*s25_13127;
extern char*s25_13130;
extern char*s25_582057685;
extern char*s25_1288899863;
extern char*s25_997;
extern char*s25_262181241;
extern char*s25_968328357;
extern char*s25_56485;
extern char*s61_546849747;
extern char*s25_1793755989;
extern char*s25_1315952470;
extern char*s25_1186886054;
extern char*s25_953418799;
extern char*s25_863614211;
extern char*s25_384844997;
extern char*s25_69196;
extern char*s25_1009749943;
extern char*s25_321084001;
extern char*s25_784119050;
extern char*s25_14186;
extern char*s61_445180577;
extern char*s25_1224770635;
extern char*s50_7407872;
extern char*s25_179980337;
extern char*s25_1184979933;
extern char*s25_1033979069;
extern char*s25_1046453349;
extern char*s25_2198;
extern char*s25_1071906274;
extern char*s25_57731;
extern char*s25_1395793447;
extern char*s25_1032527758;
extern char*s25_2473;
extern char*s25_2029623371;
extern char*s25_2614;
extern char*s25_1104285512;
extern char*s25_64246;
extern char*s25_306365602;
extern char*s25_1276852086;
extern char*s25_864605964;
extern char*s25_894124683;
extern char*s25_461537271;
extern char*s56_1652635404;
extern char*s25_1702476960;
extern char*s25_111059567;
extern char*s25_958470591;
extern char*s59_525852488;
extern char*s25_1618319333;
extern char*s25_616862766;
extern char*s25_9334699;
extern char*s25_1303486749;
extern char*s25_695202130;
extern char*s25_62141258;
extern char*s25_329871;
extern char*s25_59254;
extern char*s25_615602212;
extern char*s25_1492187474;
extern char*s25_925698945;
extern char*s25_268982;
extern char*s25_1967032801;
extern char*s56_525349142;
extern char*s25_2089597834;
extern char*s25_1577219632;
extern char*s25_293974;
extern char*s25_328099401;
extern char*s25_337289;
extern char*s59_109369943;
extern char*s58_275872;
extern char*s59_873484181;
extern char*s25_2096629084;
extern char*s25_1408959593;
extern char*s25_1726621843;
extern char*s25_1332170574;
extern char*s60_153233041;
extern char*s25_1047631513;
extern char*s25_257732;
extern char*s60_753822955;
extern char*s25_1479481184;
extern char*s25_979195894;
extern char*s25_282724;
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/no_check.h) is automatically included
  when `ace.no_check' is true (ie. all modes except mode -boost).
*/

void se_prinT0(FILE* file,T0** o);
void se_prinT1(FILE* file,EIF_INTEGER_8* o);
void se_prinT2(FILE* file,EIF_INTEGER* o);
void se_prinT3(FILE* file,EIF_CHARACTER* o);
void se_prinT4(FILE* file,EIF_REAL_32* o);
void se_prinT5(FILE* file,EIF_REAL_64* o);
void se_prinT12(FILE* file,EIF_REAL_EXTENDED* o);
void se_prinT6(FILE* file,EIF_BOOLEAN* o);
void se_prinT7(FILE* file,EIF_STRING* o);
void se_prinT8(FILE* file,EIF_POINTER* o);
void se_prinT10(FILE* file,EIF_INTEGER_16* o);
void se_prinT11(FILE* file,EIF_INTEGER_64* o);

/*
   This type is used to store a position in some Eiffel source file.
   It must be compatible with the implementation of class POSITION.
*/
typedef unsigned int se_position;

#define se_position2line(position) (((position) & 1) \
  ? ((EIF_INTEGER)(((position) >> 1) & 0x7FFF)) \
  : ((EIF_INTEGER)(((position) >> 8) & 0x1FFF)))

#define se_position2column(position) (((position) & 1) \
  ? 0 \
  : ((EIF_INTEGER)(((position) >> 1) & 0x7F)))

#define se_position2path_id(position) (((position) & 1) \
  ? ((position) >> 17) \
  : ((position) >> 21))

/*
  To be able to print a stack frame in a human readable format :
*/
typedef struct _se_frame_descriptor se_frame_descriptor;
struct _se_frame_descriptor {
  char* name; /* Eiffel name of the routine. */
  int use_current; /* Flag is 1 when this routine use Current. */
  int local_count; /* Number of C variables to print. */
  char* local_format; /* Format/type information. */
  int assertion_flag; /* 1 when assertions can be checked. */
};

/* For flat_check opion */
extern int assertion_depth;

/*
  To keep the track of execution in order to be able to print a
  dump when things goes wrong :
*/
typedef struct _se_dump_stack se_dump_stack;
struct _se_dump_stack {
  se_frame_descriptor* fd;
  void* current; /* NULL when not used. */
  se_position p; /* The current position. */
  se_dump_stack* caller; /* Back to the caller. */
  se_dump_stack* exception_origin; /* The exception origin if we are handling an exception. That object was malloc'ed */
  void*** locals;
};

se_dump_stack* se_dst;
#define set_se_dst(ds) se_dst=(ds)

int se_stack_size(se_dump_stack* ds);
void se_print_run_time_stack(void);
void se_print_run_time_stack_in(FILE* file);
int se_print_one_frame(se_dump_stack*ds);
int se_print_one_frame_in(FILE* file, se_dump_stack*ds);

int se_rci(se_dump_stack*caller,void*C);
void error0(char*m,char*vv);
void error1(char*m,se_position position);
void error2(T0* o,se_position position);
T0* vc(T0* o, se_position position);
T0* se_string_inspect_check(T0* o, se_position position);
T0* ci(int id, T0* o, se_position position);
void ac_req(int v, char* vv);
void ac_ens(int v, char* vv);
void ac_inv(int v, char* vv);
void ac_liv(int v, char* vv);
void ac_insp(int v);
int ac_lvc(int lc,int lv1,int lv2);
void ac_civ(int v,char*vv);
T0* se_evobt(T0* o,se_position position);
void se_signal_handler(int sig);
void se_gc_check_id(void*o,int id);

/* The two following instructions are used by the exceptions system to keep
   the stack trace when jumping back to the retry clause */
se_dump_stack* se_new_dump_stack(se_dump_stack* copy);
void se_delete_dump_stack(se_dump_stack* ds);

#ifndef SE_TRACE
#    define set_dump_stack_top(ds) set_se_dst(ds)
#else
#    define set_dump_stack_top(ds) \
       do { \
         se_print_call_trace(ds); \
         set_se_dst(ds); \
       } while(0)
#endif
#define FSOC_SIZE 8192
#define RSOC_SIZE 32768
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
   This file (SmartEiffel/sys/runtime/gc_lib.h) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has
   been selected).
*/

#define SE_GC_LIB 1

#define SE_GC_LOW_MEMORY_STRATEGY 0
#define SE_GC_HIGH_MEMORY_STRATEGY 1
#define SE_GC_DEFAULT_MEMORY_STRATEGY 2
extern int se_gc_strategy;


#define RSOH_UNMARKED 15253
#define RSOH_FREE 1
#define RSOH_MARKED 2


#define FSOH_UNMARKED ((void *) 1)
#define FSOH_MARKED   ((void *) 2)

/* To codify the state and the type of some Memory Chunk, we are
   using the following definitions :
*/
#define FSO_FREE_CHUNK  (-2)
#define RSO_FREE_CHUNK  (-1)
#define RSO_USED_CHUNK  ( 0)
#define FSO_STORE_CHUNK ( 1)
#define FSO_USED_CHUNK  ( 2)
#define FREE_CHUNK(x) ((x)<0)

/* Minimum size for a store area in a ReSizable Objects Chunk :
 */
#define RSOC_MIN_STORE 512

/* The default channel used to print -gc_info flag information :
*/
#define SE_GCINFO SE_ERR

extern int collector_counter; /* MEMORY.collector_counter */

typedef struct s_mch mch; /* Memory Chunk Header. */
typedef struct s_fsoc fsoc; /* Fixed Size Objects Chunk. */
typedef union u_rsoh rsoh; /* ReSizable Object Header. */
typedef struct s_fll_rsoh fll_rsoh;
typedef struct s_rsoc rsoc; /* ReSizable Objects Chunk. */
typedef struct s_na_env na_env; /* Native Array ENVironment. */


struct s_mch{
  unsigned int size; /* In number of bytes (actual argument of malloc).*/
  int state_type; /* One value in : RSO_USED_CHUNK,
                     FREE_CHUNK, FSO_STORE_CHUNK, FSO_USED_CHUNK */
  void(*amfp)(mch*,void*); /* Align Mark Function Pointer. */
  void(*swfp)(mch*); /* SWeep Function Pointer. */
};

struct s_fsoc{
  mch header; /* Common header for fsoc and rsoc. */
  fsoc* next; /* The next one when in free list (fsocfl). */
  int count_minus_one;
  double first_object;
};

typedef struct _rso_header rso_header;

struct _rso_header{
    unsigned int size;
    int magic_flag;     /* RSOH_MARKED when used,
			   RSOH_FREE when free,
			   else RSOH_UNMARKED */
};

typedef union u_fso_header fso_header;

union u_fso_header{
  void* flag;
  void* next;/* accurately typed as gcXX* in actual fso headers */
};

union u_rsoh{
  rso_header header;
  double padding;
};

struct s_fll_rsoh {
  rso_header rsoh_field;
  fll_rsoh* nextflol;
};

struct s_rsoc{
  mch header; /* Common header for fsoc and rsoc. */
  unsigned int isize; /* Initial size (at malloc time) to detect split chunks. */
  rsoc* next; /* Next one when in free list (rsocfl) or in na_env->chunk_list. */
  fll_rsoh*free_list_of_large; /* Intra. free list. */
  na_env*nae;
  rsoh first_header;
};

struct s_na_env{
  unsigned int store_left;
  rsoh* store;
  rsoc*store_chunk;
  rsoc*chunk_list; /*List of chunks of that type that have a non-null free_list_of_large*/
  void (*gc_mark)(T0*);
  int space_used;
};

extern void**stack_bottom;
extern mch**gcmt;
extern int gcmt_max;
extern int gcmt_used;
extern int gc_is_off;
extern fsoc* fsocfl;
extern unsigned int fsoc_count;
extern unsigned int rsoc_count;
extern void*gcmt_tail_addr;

void gc_sweep(void);
void gc_mark(void* p);
mch* gc_find_chunk(void* p);
int gc_stack_size(void);
int garbage_delayed(void);
void gc_update_ceils(void);
char*new_na(na_env*nae,unsigned int size);
unsigned int fsocfl_count(void);
unsigned int rsocfl_count(void);
void gc_dispose_before_exit(void);
void mark_stack_and_registers (void);
fsoc* gc_fsoc_get1(void);
fsoc* gc_fsoc_get2(void);

int gc_memory_used(void);
extern unsigned int fsoc_count_ceil;
extern unsigned int rsoc_count_ceil;
/*NATIVE_ARRAY[STRING]*/T0* r185item(se_dump_stack*caller,T185 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/T6 r185is_not_null(se_dump_stack*caller,T185 C);
/*NATIVE_ARRAY[STRING]*/void r185put(se_dump_stack*caller,T185 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/T6 r185all_default(se_dump_stack*caller,T185 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/void r185clear_all(se_dump_stack*caller,T185 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/void r185set_all_with(se_dump_stack*caller,T185 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/T185 r185realloc(se_dump_stack*caller,T185 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/void r185copy_from(se_dump_stack*caller,T185 C,T185 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/T185 r185calloc(se_dump_stack*caller,T185 C,T2 a1);
/*NATIVE_ARRAY[UTILISATEUR]*/T0* r184item(se_dump_stack*caller,T184 C,T2 a1);
/*NATIVE_ARRAY[UTILISATEUR]*/T6 r184is_not_null(se_dump_stack*caller,T184 C);
/*NATIVE_ARRAY[UTILISATEUR]*/void r184put(se_dump_stack*caller,T184 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[UTILISATEUR]*/T6 r184all_default(se_dump_stack*caller,T184 C,T2 a1);
/*NATIVE_ARRAY[UTILISATEUR]*/void r184clear_all(se_dump_stack*caller,T184 C,T2 a1);
/*NATIVE_ARRAY[UTILISATEUR]*/void r184set_all_with(se_dump_stack*caller,T184 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[UTILISATEUR]*/T184 r184realloc(se_dump_stack*caller,T184 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[UTILISATEUR]*/void r184copy_from(se_dump_stack*caller,T184 C,T184 a1,T2 a2);
/*NATIVE_ARRAY[UTILISATEUR]*/T184 r184calloc(se_dump_stack*caller,T184 C,T2 a1);
/*NATIVE_ARRAY[ACTEUR]*/T0* r182item(se_dump_stack*caller,T182 C,T2 a1);
/*NATIVE_ARRAY[ACTEUR]*/T6 r182is_not_null(se_dump_stack*caller,T182 C);
/*NATIVE_ARRAY[ACTEUR]*/void r182put(se_dump_stack*caller,T182 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ACTEUR]*/T6 r182all_default(se_dump_stack*caller,T182 C,T2 a1);
/*NATIVE_ARRAY[ACTEUR]*/void r182clear_all(se_dump_stack*caller,T182 C,T2 a1);
/*NATIVE_ARRAY[ACTEUR]*/void r182set_all_with(se_dump_stack*caller,T182 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ACTEUR]*/T182 r182realloc(se_dump_stack*caller,T182 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[ACTEUR]*/void r182copy_from(se_dump_stack*caller,T182 C,T182 a1,T2 a2);
/*NATIVE_ARRAY[ACTEUR]*/T182 r182calloc(se_dump_stack*caller,T182 C,T2 a1);
/*NATIVE_ARRAY[AUTEUR]*/T0* r181item(se_dump_stack*caller,T181 C,T2 a1);
/*NATIVE_ARRAY[AUTEUR]*/T6 r181is_not_null(se_dump_stack*caller,T181 C);
/*NATIVE_ARRAY[AUTEUR]*/void r181put(se_dump_stack*caller,T181 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[AUTEUR]*/T6 r181all_default(se_dump_stack*caller,T181 C,T2 a1);
/*NATIVE_ARRAY[AUTEUR]*/void r181clear_all(se_dump_stack*caller,T181 C,T2 a1);
/*NATIVE_ARRAY[AUTEUR]*/void r181set_all_with(se_dump_stack*caller,T181 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[AUTEUR]*/T181 r181realloc(se_dump_stack*caller,T181 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[AUTEUR]*/void r181copy_from(se_dump_stack*caller,T181 C,T181 a1,T2 a2);
/*NATIVE_ARRAY[AUTEUR]*/T181 r181calloc(se_dump_stack*caller,T181 C,T2 a1);
/*NATIVE_ARRAY[REALISATEUR]*/T0* r180item(se_dump_stack*caller,T180 C,T2 a1);
/*NATIVE_ARRAY[REALISATEUR]*/T6 r180is_not_null(se_dump_stack*caller,T180 C);
/*NATIVE_ARRAY[REALISATEUR]*/void r180put(se_dump_stack*caller,T180 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[REALISATEUR]*/T6 r180all_default(se_dump_stack*caller,T180 C,T2 a1);
/*NATIVE_ARRAY[REALISATEUR]*/void r180clear_all(se_dump_stack*caller,T180 C,T2 a1);
/*NATIVE_ARRAY[REALISATEUR]*/void r180set_all_with(se_dump_stack*caller,T180 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[REALISATEUR]*/T180 r180realloc(se_dump_stack*caller,T180 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[REALISATEUR]*/void r180copy_from(se_dump_stack*caller,T180 C,T180 a1,T2 a2);
/*NATIVE_ARRAY[REALISATEUR]*/T180 r180calloc(se_dump_stack*caller,T180 C,T2 a1);
/*NATIVE_ARRAY[LIVRE]*/T0* r183item(se_dump_stack*caller,T183 C,T2 a1);
/*NATIVE_ARRAY[LIVRE]*/T6 r183is_not_null(se_dump_stack*caller,T183 C);
/*NATIVE_ARRAY[LIVRE]*/void r183put(se_dump_stack*caller,T183 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[LIVRE]*/T6 r183all_default(se_dump_stack*caller,T183 C,T2 a1);
/*NATIVE_ARRAY[LIVRE]*/void r183clear_all(se_dump_stack*caller,T183 C,T2 a1);
/*NATIVE_ARRAY[LIVRE]*/void r183set_all_with(se_dump_stack*caller,T183 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[LIVRE]*/T183 r183realloc(se_dump_stack*caller,T183 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[LIVRE]*/void r183copy_from(se_dump_stack*caller,T183 C,T183 a1,T2 a2);
/*NATIVE_ARRAY[LIVRE]*/T183 r183calloc(se_dump_stack*caller,T183 C,T2 a1);
/*NATIVE_ARRAY[DVD]*/T0* r179item(se_dump_stack*caller,T179 C,T2 a1);
/*NATIVE_ARRAY[DVD]*/T6 r179is_not_null(se_dump_stack*caller,T179 C);
/*NATIVE_ARRAY[DVD]*/void r179put(se_dump_stack*caller,T179 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[DVD]*/T6 r179all_default(se_dump_stack*caller,T179 C,T2 a1);
/*NATIVE_ARRAY[DVD]*/void r179clear_all(se_dump_stack*caller,T179 C,T2 a1);
/*NATIVE_ARRAY[DVD]*/void r179set_all_with(se_dump_stack*caller,T179 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[DVD]*/T179 r179realloc(se_dump_stack*caller,T179 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[DVD]*/void r179copy_from(se_dump_stack*caller,T179 C,T179 a1,T2 a2);
/*NATIVE_ARRAY[DVD]*/T179 r179calloc(se_dump_stack*caller,T179 C,T2 a1);
/*NATIVE_ARRAY[MEDIA]*/T0* r178item(se_dump_stack*caller,T178 C,T2 a1);
/*NATIVE_ARRAY[MEDIA]*/T6 r178is_not_null(se_dump_stack*caller,T178 C);
/*NATIVE_ARRAY[MEDIA]*/void r178put(se_dump_stack*caller,T178 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[MEDIA]*/T6 r178all_default(se_dump_stack*caller,T178 C,T2 a1);
/*NATIVE_ARRAY[MEDIA]*/void r178clear_all(se_dump_stack*caller,T178 C,T2 a1);
/*NATIVE_ARRAY[MEDIA]*/void r178set_all_with(se_dump_stack*caller,T178 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[MEDIA]*/T178 r178realloc(se_dump_stack*caller,T178 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[MEDIA]*/void r178copy_from(se_dump_stack*caller,T178 C,T178 a1,T2 a2);
/*NATIVE_ARRAY[MEDIA]*/T178 r178calloc(se_dump_stack*caller,T178 C,T2 a1);
/*STD_OUTPUT*/void r48write_buffer(se_dump_stack*caller,T48* C);
/*STD_OUTPUT*/T6 r48can_put_character(se_dump_stack*caller,T48* C,T3 a1);
extern T0*oBC13std_output;
extern int fBC13std_output;
/*STD_OUTPUT*/T0* r48std_output(se_dump_stack*caller,T48* C);
/*STD_OUTPUT*/void r48dispose(se_dump_stack*caller,T48* C);
/*STD_OUTPUT*/void r48filtered_flush(se_dump_stack*caller,T48* C);
/*STD_OUTPUT*/void r48se_atexit(se_dump_stack*caller,T48* C);
/*STD_OUTPUT*/void r48filtered_put_character(se_dump_stack*caller,T48* C,T3 a1);
/*STD_OUTPUT*/void r48make(se_dump_stack*caller,T48* C);
/*STD_OUTPUT*/T6 r48is_filtered(se_dump_stack*caller,T48* C);
/*STD_OUTPUT*/void r48put_character(se_dump_stack*caller,T48* C,T3 a1);
/*STD_OUTPUT*/void r48flush(se_dump_stack*caller,T48* C);
extern T0*oBC13std_input;
extern int fBC13std_input;
/*STD_INPUT*/T0* r49std_input(se_dump_stack*caller,T49* C);
/*STD_INPUT*/T0* r49std_output(se_dump_stack*caller,T49* C);
/*STD_INPUT*/void r49fill_buffer(se_dump_stack*caller,T49* C);
/*STD_INPUT*/void r49dispose(se_dump_stack*caller,T49* C);
/*STD_INPUT*/void r49read_character(se_dump_stack*caller,T49* C);
/*STD_INPUT*/T6 r49can_unread_character(se_dump_stack*caller,T49* C);
/*STD_INPUT*/T6 r49valid_last_character(se_dump_stack*caller,T49* C);
/*STD_INPUT*/T3 r49last_character(se_dump_stack*caller,T49* C);
/*STD_INPUT*/T3 r49filtered_last_character(se_dump_stack*caller,T49* C);
/*STD_INPUT*/void r49filtered_read_character(se_dump_stack*caller,T49* C);
/*STD_INPUT*/void r49make(se_dump_stack*caller,T49* C);
/*STD_INPUT*/T6 r49is_filtered(se_dump_stack*caller,T49* C);
/*ARRAY[STRING]*/T2 r177count(se_dump_stack*caller,T177* C);
/*ARRAY[STRING]*/T0* r177last(se_dump_stack*caller,T177* C);
/*ARRAY[STRING]*/T6 r177valid_index(se_dump_stack*caller,T177* C,T2 a1);
/*ARRAY[STRING]*/T6 r177is_empty(se_dump_stack*caller,T177* C);
/*ARRAY[STRING]*/T0* r177item(se_dump_stack*caller,T177* C,T2 a1);
/*ARRAY[STRING]*/void r177put(se_dump_stack*caller,T177* C,T0* a1,T2 a2);
/*ARRAY[STRING]*/void r177mark_native_arrays(se_dump_stack*caller,T177* C);
/*ARRAY[STRING]*/T6 r177all_default(se_dump_stack*caller,T177* C);
/*ARRAY[STRING]*/void r177clear_all(se_dump_stack*caller,T177* C);
/*ARRAY[STRING]*/void r177set_all_with(se_dump_stack*caller,T177* C,T0* a1);
/*ARRAY[STRING]*/void r177ensure_capacity_and_bounds(se_dump_stack*caller,T177* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[STRING]*/void r177add_last(se_dump_stack*caller,T177* C,T0* a1);
/*ARRAY[STRING]*/void r177with_capacity(se_dump_stack*caller,T177* C,T2 a1,T2 a2);
extern se_frame_descriptor se_ifd177;
T177*se_i177(se_dump_stack*caller,T177*C);
/*TEXT_FILE_READ*/void r64fill_buffer(se_dump_stack*caller,T64* C);
/*TEXT_FILE_READ*/void r64dispose(se_dump_stack*caller,T64* C);
/*TEXT_FILE_READ*/T6 r64can_unread_character(se_dump_stack*caller,T64* C);
/*TEXT_FILE_READ*/void r64read_line_in(se_dump_stack*caller,T64* C,T0* a1);
/*TEXT_FILE_READ*/T6 r64valid_last_character(se_dump_stack*caller,T64* C);
/*TEXT_FILE_READ*/T3 r64filtered_last_character(se_dump_stack*caller,T64* C);
/*TEXT_FILE_READ*/void r64filtered_read_line_in(se_dump_stack*caller,T64* C,T0* a1);
/*TEXT_FILE_READ*/void r64make(se_dump_stack*caller,T64* C);
/*TEXT_FILE_READ*/void r64connect_to(se_dump_stack*caller,T64* C,T0* a1);
/*TEXT_FILE_READ*/void r64disconnect(se_dump_stack*caller,T64* C);
/*TEXT_FILE_READ*/T6 r64is_filtered(se_dump_stack*caller,T64* C);
/*TEXT_FILE_READ*/T6 r64is_connected(se_dump_stack*caller,T64* C);
/*ARRAY[UTILISATEUR]*/T2 r176count(se_dump_stack*caller,T176* C);
/*ARRAY[UTILISATEUR]*/T0* r176last(se_dump_stack*caller,T176* C);
/*ARRAY[UTILISATEUR]*/T6 r176valid_index(se_dump_stack*caller,T176* C,T2 a1);
/*ARRAY[UTILISATEUR]*/T6 r176is_empty(se_dump_stack*caller,T176* C);
/*ARRAY[UTILISATEUR]*/T0* r176item(se_dump_stack*caller,T176* C,T2 a1);
/*ARRAY[UTILISATEUR]*/void r176put(se_dump_stack*caller,T176* C,T0* a1,T2 a2);
/*ARRAY[UTILISATEUR]*/void r176mark_native_arrays(se_dump_stack*caller,T176* C);
/*ARRAY[UTILISATEUR]*/T6 r176all_default(se_dump_stack*caller,T176* C);
/*ARRAY[UTILISATEUR]*/void r176clear_all(se_dump_stack*caller,T176* C);
/*ARRAY[UTILISATEUR]*/void r176set_all_with(se_dump_stack*caller,T176* C,T0* a1);
/*ARRAY[UTILISATEUR]*/void r176ensure_capacity_and_bounds(se_dump_stack*caller,T176* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[UTILISATEUR]*/void r176add_last(se_dump_stack*caller,T176* C,T0* a1);
/*ARRAY[UTILISATEUR]*/void r176with_capacity(se_dump_stack*caller,T176* C,T2 a1,T2 a2);
extern se_frame_descriptor se_ifd176;
T176*se_i176(se_dump_stack*caller,T176*C);
/*ACTEUR*/T6 r60is_default(se_dump_stack*caller,T60* C);
/*ACTEUR*/T0* r60default(se_dump_stack*caller,T60* C);
/*ACTEUR*/T0* r60get_nom(se_dump_stack*caller,T60* C);
/*ACTEUR*/void r60set_prenom(se_dump_stack*caller,T60* C,T0* a1);
/*ACTEUR*/T0* r60get_prenom(se_dump_stack*caller,T60* C);
/*ACTEUR*/void r60set_nom(se_dump_stack*caller,T60* C,T0* a1);
/*ACTEUR*/void r60make_personne(se_dump_stack*caller,T60* C);
/*ACTEUR*/void r60make(se_dump_stack*caller,T60* C);
/*ACTEUR*/T0* r60get_lst_films(se_dump_stack*caller,T60* C);
/*ACTEUR*/void r60ajouter_film(se_dump_stack*caller,T60* C,T0* a1);
/*ACTEUR*/T0* r60to_string(se_dump_stack*caller,T60* C);
/*ARRAY[ACTEUR]*/T2 r174count(se_dump_stack*caller,T174* C);
/*ARRAY[ACTEUR]*/T0* r174last(se_dump_stack*caller,T174* C);
/*ARRAY[ACTEUR]*/T6 r174valid_index(se_dump_stack*caller,T174* C,T2 a1);
/*ARRAY[ACTEUR]*/T6 r174is_empty(se_dump_stack*caller,T174* C);
/*ARRAY[ACTEUR]*/T0* r174item(se_dump_stack*caller,T174* C,T2 a1);
/*ARRAY[ACTEUR]*/void r174put(se_dump_stack*caller,T174* C,T0* a1,T2 a2);
/*ARRAY[ACTEUR]*/void r174mark_native_arrays(se_dump_stack*caller,T174* C);
/*ARRAY[ACTEUR]*/T6 r174all_default(se_dump_stack*caller,T174* C);
/*ARRAY[ACTEUR]*/void r174clear_all(se_dump_stack*caller,T174* C);
/*ARRAY[ACTEUR]*/void r174set_all_with(se_dump_stack*caller,T174* C,T0* a1);
/*ARRAY[ACTEUR]*/void r174ensure_capacity_and_bounds(se_dump_stack*caller,T174* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[ACTEUR]*/void r174add_last(se_dump_stack*caller,T174* C,T0* a1);
/*ARRAY[ACTEUR]*/void r174with_capacity(se_dump_stack*caller,T174* C,T2 a1,T2 a2);
extern se_frame_descriptor se_ifd174;
T174*se_i174(se_dump_stack*caller,T174*C);
/*AUTEUR*/T6 r56is_default(se_dump_stack*caller,T56* C);
/*AUTEUR*/T0* r56default(se_dump_stack*caller,T56* C);
/*AUTEUR*/T0* r56get_nom(se_dump_stack*caller,T56* C);
/*AUTEUR*/void r56set_prenom(se_dump_stack*caller,T56* C,T0* a1);
/*AUTEUR*/T0* r56get_prenom(se_dump_stack*caller,T56* C);
/*AUTEUR*/void r56set_nom(se_dump_stack*caller,T56* C,T0* a1);
/*AUTEUR*/void r56make_personne(se_dump_stack*caller,T56* C);
/*AUTEUR*/T0* r56get_lst_livres(se_dump_stack*caller,T56* C);
/*AUTEUR*/void r56make(se_dump_stack*caller,T56* C);
/*AUTEUR*/void r56ajouter_livre(se_dump_stack*caller,T56* C,T0* a1);
/*AUTEUR*/T0* r56to_string(se_dump_stack*caller,T56* C);
/*ARRAY[AUTEUR]*/T2 r173count(se_dump_stack*caller,T173* C);
/*ARRAY[AUTEUR]*/T0* r173last(se_dump_stack*caller,T173* C);
/*ARRAY[AUTEUR]*/T6 r173valid_index(se_dump_stack*caller,T173* C,T2 a1);
/*ARRAY[AUTEUR]*/T6 r173is_empty(se_dump_stack*caller,T173* C);
/*ARRAY[AUTEUR]*/T0* r173item(se_dump_stack*caller,T173* C,T2 a1);
/*ARRAY[AUTEUR]*/void r173put(se_dump_stack*caller,T173* C,T0* a1,T2 a2);
/*ARRAY[AUTEUR]*/void r173mark_native_arrays(se_dump_stack*caller,T173* C);
/*ARRAY[AUTEUR]*/T6 r173all_default(se_dump_stack*caller,T173* C);
/*ARRAY[AUTEUR]*/void r173clear_all(se_dump_stack*caller,T173* C);
/*ARRAY[AUTEUR]*/void r173set_all_with(se_dump_stack*caller,T173* C,T0* a1);
/*ARRAY[AUTEUR]*/void r173ensure_capacity_and_bounds(se_dump_stack*caller,T173* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[AUTEUR]*/void r173add_last(se_dump_stack*caller,T173* C,T0* a1);
/*ARRAY[AUTEUR]*/void r173with_capacity(se_dump_stack*caller,T173* C,T2 a1,T2 a2);
extern se_frame_descriptor se_ifd173;
T173*se_i173(se_dump_stack*caller,T173*C);
/*REALISATEUR*/T6 r59is_default(se_dump_stack*caller,T59* C);
/*REALISATEUR*/T0* r59default(se_dump_stack*caller,T59* C);
/*REALISATEUR*/T0* r59get_nom(se_dump_stack*caller,T59* C);
/*REALISATEUR*/void r59set_prenom(se_dump_stack*caller,T59* C,T0* a1);
/*REALISATEUR*/T0* r59get_prenom(se_dump_stack*caller,T59* C);
/*REALISATEUR*/void r59set_nom(se_dump_stack*caller,T59* C,T0* a1);
/*REALISATEUR*/void r59make_personne(se_dump_stack*caller,T59* C);
/*REALISATEUR*/void r59make(se_dump_stack*caller,T59* C);
/*REALISATEUR*/T0* r59get_lst_films(se_dump_stack*caller,T59* C);
/*REALISATEUR*/void r59ajouter_film(se_dump_stack*caller,T59* C,T0* a1);
/*REALISATEUR*/T0* r59to_string(se_dump_stack*caller,T59* C);
/*ARRAY[REALISATEUR]*/T2 r172count(se_dump_stack*caller,T172* C);
/*ARRAY[REALISATEUR]*/T0* r172last(se_dump_stack*caller,T172* C);
/*ARRAY[REALISATEUR]*/T6 r172valid_index(se_dump_stack*caller,T172* C,T2 a1);
/*ARRAY[REALISATEUR]*/T6 r172is_empty(se_dump_stack*caller,T172* C);
/*ARRAY[REALISATEUR]*/T0* r172item(se_dump_stack*caller,T172* C,T2 a1);
/*ARRAY[REALISATEUR]*/void r172put(se_dump_stack*caller,T172* C,T0* a1,T2 a2);
/*ARRAY[REALISATEUR]*/void r172mark_native_arrays(se_dump_stack*caller,T172* C);
/*ARRAY[REALISATEUR]*/T6 r172all_default(se_dump_stack*caller,T172* C);
/*ARRAY[REALISATEUR]*/void r172clear_all(se_dump_stack*caller,T172* C);
/*ARRAY[REALISATEUR]*/void r172set_all_with(se_dump_stack*caller,T172* C,T0* a1);
/*ARRAY[REALISATEUR]*/void r172ensure_capacity_and_bounds(se_dump_stack*caller,T172* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[REALISATEUR]*/void r172add_last(se_dump_stack*caller,T172* C,T0* a1);
/*ARRAY[REALISATEUR]*/void r172with_capacity(se_dump_stack*caller,T172* C,T2 a1,T2 a2);
extern se_frame_descriptor se_ifd172;
T172*se_i172(se_dump_stack*caller,T172*C);
/*LIVRE*/T6 r50is_default(se_dump_stack*caller,T50* C);
/*LIVRE*/T0* r50default(se_dump_stack*caller,T50* C);
/*LIVRE*/T0* r50get_titre(se_dump_stack*caller,T50* C);
/*LIVRE*/void r50set_nombre_exemplaires(se_dump_stack*caller,T50* C,T2 a1);
/*LIVRE*/void r50set_titre(se_dump_stack*caller,T50* C,T0* a1);
/*LIVRE*/void r50make_media(se_dump_stack*caller,T50* C);
/*LIVRE*/void r50set_auteur(se_dump_stack*caller,T50* C,T0* a1);
/*LIVRE*/T0* r50get_auteur(se_dump_stack*caller,T50* C);
/*LIVRE*/void r50make(se_dump_stack*caller,T50* C);
/*LIVRE*/T0* r50to_string(se_dump_stack*caller,T50* C);
/*ARRAY[LIVRE]*/T2 r175count(se_dump_stack*caller,T175* C);
/*ARRAY[LIVRE]*/T0* r175last(se_dump_stack*caller,T175* C);
/*ARRAY[LIVRE]*/T6 r175valid_index(se_dump_stack*caller,T175* C,T2 a1);
/*ARRAY[LIVRE]*/T6 r175is_empty(se_dump_stack*caller,T175* C);
/*ARRAY[LIVRE]*/T0* r175item(se_dump_stack*caller,T175* C,T2 a1);
/*ARRAY[LIVRE]*/void r175put(se_dump_stack*caller,T175* C,T0* a1,T2 a2);
/*ARRAY[LIVRE]*/void r175mark_native_arrays(se_dump_stack*caller,T175* C);
/*ARRAY[LIVRE]*/T6 r175all_default(se_dump_stack*caller,T175* C);
/*ARRAY[LIVRE]*/void r175clear_all(se_dump_stack*caller,T175* C);
/*ARRAY[LIVRE]*/void r175set_all_with(se_dump_stack*caller,T175* C,T0* a1);
/*ARRAY[LIVRE]*/void r175ensure_capacity_and_bounds(se_dump_stack*caller,T175* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[LIVRE]*/void r175add_last(se_dump_stack*caller,T175* C,T0* a1);
/*ARRAY[LIVRE]*/void r175with_capacity(se_dump_stack*caller,T175* C,T2 a1,T2 a2);
extern se_frame_descriptor se_ifd175;
T175*se_i175(se_dump_stack*caller,T175*C);
/*DVD*/T6 r58is_default(se_dump_stack*caller,T58* C);
/*DVD*/T0* r58default(se_dump_stack*caller,T58* C);
/*DVD*/T0* r58get_titre(se_dump_stack*caller,T58* C);
/*DVD*/void r58set_nombre_exemplaires(se_dump_stack*caller,T58* C,T2 a1);
/*DVD*/void r58set_titre(se_dump_stack*caller,T58* C,T0* a1);
/*DVD*/void r58make_media(se_dump_stack*caller,T58* C);
/*DVD*/void r58make(se_dump_stack*caller,T58* C);
/*DVD*/T2 r58get_annee(se_dump_stack*caller,T58* C);
/*DVD*/void r58ajouter_realisateur(se_dump_stack*caller,T58* C,T0* a1);
/*DVD*/T0* r58get_lst_acteurs(se_dump_stack*caller,T58* C);
/*DVD*/T0* r58get_lst_realisateurs(se_dump_stack*caller,T58* C);
/*DVD*/void r58set_annee(se_dump_stack*caller,T58* C,T2 a1);
/*DVD*/void r58set_type(se_dump_stack*caller,T58* C,T0* a1);
/*DVD*/void r58ajouter_acteur(se_dump_stack*caller,T58* C,T0* a1);
/*DVD*/T0* r58to_string(se_dump_stack*caller,T58* C);
/*ARRAY[DVD]*/T2 r171count(se_dump_stack*caller,T171* C);
/*ARRAY[DVD]*/T0* r171last(se_dump_stack*caller,T171* C);
/*ARRAY[DVD]*/T6 r171valid_index(se_dump_stack*caller,T171* C,T2 a1);
/*ARRAY[DVD]*/T6 r171is_empty(se_dump_stack*caller,T171* C);
/*ARRAY[DVD]*/T0* r171item(se_dump_stack*caller,T171* C,T2 a1);
/*ARRAY[DVD]*/void r171put(se_dump_stack*caller,T171* C,T0* a1,T2 a2);
/*ARRAY[DVD]*/void r171mark_native_arrays(se_dump_stack*caller,T171* C);
/*ARRAY[DVD]*/T6 r171all_default(se_dump_stack*caller,T171* C);
/*ARRAY[DVD]*/void r171clear_all(se_dump_stack*caller,T171* C);
/*ARRAY[DVD]*/void r171set_all_with(se_dump_stack*caller,T171* C,T0* a1);
/*ARRAY[DVD]*/void r171ensure_capacity_and_bounds(se_dump_stack*caller,T171* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[DVD]*/void r171add_last(se_dump_stack*caller,T171* C,T0* a1);
/*ARRAY[DVD]*/void r171with_capacity(se_dump_stack*caller,T171* C,T2 a1,T2 a2);
extern se_frame_descriptor se_ifd171;
T171*se_i171(se_dump_stack*caller,T171*C);
/*ARRAY[MEDIA]*/T2 r170count(se_dump_stack*caller,T170* C);
/*ARRAY[MEDIA]*/T0* r170last(se_dump_stack*caller,T170* C);
/*ARRAY[MEDIA]*/T6 r170valid_index(se_dump_stack*caller,T170* C,T2 a1);
/*ARRAY[MEDIA]*/T6 r170is_empty(se_dump_stack*caller,T170* C);
/*ARRAY[MEDIA]*/T0* r170item(se_dump_stack*caller,T170* C,T2 a1);
/*ARRAY[MEDIA]*/void r170put(se_dump_stack*caller,T170* C,T0* a1,T2 a2);
/*ARRAY[MEDIA]*/void r170mark_native_arrays(se_dump_stack*caller,T170* C);
/*ARRAY[MEDIA]*/T6 r170all_default(se_dump_stack*caller,T170* C);
/*ARRAY[MEDIA]*/void r170clear_all(se_dump_stack*caller,T170* C);
/*ARRAY[MEDIA]*/void r170set_all_with(se_dump_stack*caller,T170* C,T0* a1);
/*ARRAY[MEDIA]*/void r170ensure_capacity_and_bounds(se_dump_stack*caller,T170* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[MEDIA]*/void r170add_last(se_dump_stack*caller,T170* C,T0* a1);
/*ARRAY[MEDIA]*/void r170with_capacity(se_dump_stack*caller,T170* C,T2 a1,T2 a2);
extern se_frame_descriptor se_ifd170;
T170*se_i170(se_dump_stack*caller,T170*C);
/*UTILISATEUR*/T6 r61is_default(se_dump_stack*caller,T61* C);
/*UTILISATEUR*/T0* r61default(se_dump_stack*caller,T61* C);
/*UTILISATEUR*/void r61set_prenom(se_dump_stack*caller,T61* C,T0* a1);
/*UTILISATEUR*/T0* r61get_prenom(se_dump_stack*caller,T61* C);
/*UTILISATEUR*/void r61set_nom(se_dump_stack*caller,T61* C,T0* a1);
/*UTILISATEUR*/void r61make(se_dump_stack*caller,T61* C);
/*UTILISATEUR*/T0* r61get_identifiant(se_dump_stack*caller,T61* C);
/*UTILISATEUR*/T6 r61is_admin(se_dump_stack*caller,T61* C);
/*UTILISATEUR*/void r61set_identifiant(se_dump_stack*caller,T61* C,T0* a1);
/*UTILISATEUR*/void r61set_admin(se_dump_stack*caller,T61* C,T6 a1);
/*UTILISATEUR*/T0* r61to_string(se_dump_stack*caller,T61* C);
/*STD_INPUT_OUTPUT*/void r41put_string(se_dump_stack*caller,T41* C,T0* a1);
/*STD_INPUT_OUTPUT*/T0* r41std_input(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/T6 r41can_put_character(se_dump_stack*caller,T41* C,T3 a1);
/*STD_INPUT_OUTPUT*/T0* r41std_output(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/void r41dispose(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/T6 r41can_unread_character(se_dump_stack*caller,T41* C);
extern T0*oBC13io;
extern int fBC13io;
/*STD_INPUT_OUTPUT*/T0* r41io(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/void r41read_line_in(se_dump_stack*caller,T41* C,T0* a1);
/*STD_INPUT_OUTPUT*/T6 r41end_of_input(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/void r41filtered_flush(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/void r41filtered_put_character(se_dump_stack*caller,T41* C,T3 a1);
/*STD_INPUT_OUTPUT*/T6 r41valid_last_character(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/void r41read_line(se_dump_stack*caller,T41* C);
extern T0*oBC45last_string;
extern int fBC45last_string;
/*STD_INPUT_OUTPUT*/T0* r41last_string(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/T3 r41filtered_last_character(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/void r41filtered_read_line_in(se_dump_stack*caller,T41* C,T0* a1);
/*STD_INPUT_OUTPUT*/void r41filtered_read_character(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/T6 r41input_is_filtered(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/T6 r41output_is_filtered(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/void r41make(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/T6 r41is_connected(se_dump_stack*caller,T41* C);
/*STD_INPUT_OUTPUT*/void r41put_character(se_dump_stack*caller,T41* C,T3 a1);
/*STD_INPUT_OUTPUT*/void r41flush(se_dump_stack*caller,T41* C);
extern se_frame_descriptor se_ifd41;
T41*se_i41(se_dump_stack*caller,T41*C);
/*INTEGER_16*/T6 r10is_equal(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T10 r10_ix_43(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T10 r10Maximum_character_code(se_dump_stack*caller,T10 C);
/*INTEGER_16*/T6 r10_ix_6261(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T6 r10_ix_60(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T6 r10_ix_62(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T6 r10fit_integer_8(se_dump_stack*caller,T10 C);
/*INTEGER_16*/T6 r10in_range(se_dump_stack*caller,T10 C,T10 a1,T10 a2);
/*INTEGER_16*/T6 r10_ix_6061(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T2 r10hash_code(se_dump_stack*caller,T10 C);
/*INTEGER_16*/T3 r10to_character(se_dump_stack*caller,T10 C);
/*INTEGER_16*/T1 r10to_integer_8(se_dump_stack*caller,T10 C);
/*INTEGER_16*/T10 r10_ix_45(se_dump_stack*caller,T10 C,T10 a1);
/*POINTER*/T6 r8is_null(se_dump_stack*caller,T8 C);
/*BOOLEAN*/T6 r6_ix_and(se_dump_stack*caller,T6 C,T6 a1);
/*BOOLEAN*/T6 r6_px_not(se_dump_stack*caller,T6 C);
/*BOOLEAN*/T6 r6_ix_or(se_dump_stack*caller,T6 C,T6 a1);
/*INTEGER_8*/T6 r1is_equal(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T6 r1_ix_6261(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T6 r1_ix_60(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T6 r1_ix_62(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T6 r1in_range(se_dump_stack*caller,T1 C,T1 a1,T1 a2);
/*INTEGER_8*/T6 r1_ix_6061(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T2 r1hash_code(se_dump_stack*caller,T1 C);
/*INTEGER_8*/T1 r1_px_45(se_dump_stack*caller,T1 C);
/*INTEGER_8*/T1 r1_ix_45(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_32*/T6 r2is_equal(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2_ix_359292(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2_ix_43(se_dump_stack*caller,T2 C,T2 a1);
extern T0*oBC62string_buffer;
extern int fBC62string_buffer;
/*INTEGER_32*/T0* r2string_buffer(se_dump_stack*caller);
/*INTEGER_32*/T2 r2abs(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T3 r2decimal_digit(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T2 r2_ix_1246060(se_dump_stack*caller,T2 C,T1 a1);
/*INTEGER_32*/T10 r2Maximum_character_code(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T2 r2_ix_354747(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T6 r2_ix_6261(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2compare(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T6 r2_ix_60(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T6 r2_ix_62(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T6 r2in_range(se_dump_stack*caller,T2 C,T2 a1,T2 a2);
/*INTEGER_32*/T2 r2min(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T6 r2_ix_6061(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2max(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2hash_code(se_dump_stack*caller,T2 C);
/*INTEGER_32*/void r2append_in(se_dump_stack*caller,T2 C,T0* a1);
/*INTEGER_32*/T3 r2to_character(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T2 r2_ix_42(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T0* r2to_string(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T2 r2_px_45(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T2 r2_ix_45(se_dump_stack*caller,T2 C,T2 a1);
/*MEDIATHEQUE*/T0* r25io(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/T2 r25rechercher_media_par_personne(se_dump_stack*caller,T25* C,T0* a1,T0* a2);
/*MEDIATHEQUE*/void r25remplir_lst_auteurs(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/void r25initialisation(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/T0* r25rechercher_utilisateur(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/void r25remplir_lst_auteurs_realisateurs_acteurs(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25remplir_lst_users(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/T2 r25verifier_lst_acteurs(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/void r25remplir_lst_realisateurs(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/void r25ajouter_utilisateur(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25connexion(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25afficher_tableau(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/void r25remplir_lst_medias(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25afficher_menu(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/T2 r25rechercher_media_par_titre(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/void r25rechercher_media(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/void r25remplir_lst_acteurs(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/void r25make(se_dump_stack*caller,T25* C);
/*MEDIATHEQUE*/T2 r25rechercher_media_par_type(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/T2 r25verifier_lst_auteurs(se_dump_stack*caller,T25* C,T0* a1);
/*MEDIATHEQUE*/T2 r25rechercher_media_par_annee(se_dump_stack*caller,T25* C,T2 a1);
/*MEDIATHEQUE*/T2 r25verifier_lst_realisateurs(se_dump_stack*caller,T25* C,T0* a1);
/*CHARACTER*/T6 r3is_equal(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T6 r3is_default(se_dump_stack*caller,T3 C);
/*CHARACTER*/T3 r3default(se_dump_stack*caller);
/*CHARACTER*/T10 r3Maximum_character_code(se_dump_stack*caller,T3 C);
/*CHARACTER*/T10 r3Minimum_character_code(se_dump_stack*caller,T3 C);
/*CHARACTER*/T6 r3_ix_6261(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T6 r3_ix_60(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T6 r3in_range(se_dump_stack*caller,T3 C,T3 a1,T3 a2);
/*CHARACTER*/T6 r3_ix_6061(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T2 r3hash_code(se_dump_stack*caller,T3 C);
/*CHARACTER*/T3 r3to_upper(se_dump_stack*caller,T3 C);
/*CHARACTER*/T6 r3is_digit(se_dump_stack*caller,T3 C);
/*CHARACTER*/T1 r3value(se_dump_stack*caller,T3 C);
/*CHARACTER*/T6 r3is_separator(se_dump_stack*caller,T3 C);
/*CHARACTER*/T10 r3code(se_dump_stack*caller,T3 C);
/*CHARACTER*/T1 r3decimal_value(se_dump_stack*caller,T3 C);
/*CHARACTER*/T3 r3to_lower(se_dump_stack*caller,T3 C);
/*CHARACTER*/T6 r3same_as(se_dump_stack*caller,T3 C,T3 a1);
/*NATIVE_ARRAY[CHARACTER]*/void r9copy_at(se_dump_stack*caller,T9 C,T2 a1,T9 a2,T2 a3);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9fast_memcmp(se_dump_stack*caller,T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9slice_copy(se_dump_stack*caller,T9 C,T2 a1,T9 a2,T2 a3,T2 a4);
/*NATIVE_ARRAY[CHARACTER]*/T3 r9item(se_dump_stack*caller,T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9is_not_null(se_dump_stack*caller,T9 C);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9is_null(se_dump_stack*caller,T9 C);
/*NATIVE_ARRAY[CHARACTER]*/void r9put(se_dump_stack*caller,T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/T2 r9fast_reverse_index_of(se_dump_stack*caller,T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/T2 r9fast_index_of(se_dump_stack*caller,T9 C,T3 a1,T2 a2,T2 a3);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9all_default(se_dump_stack*caller,T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/void r9clear_all(se_dump_stack*caller,T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9fast_has(se_dump_stack*caller,T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/T9 r9realloc(se_dump_stack*caller,T9 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9copy_from(se_dump_stack*caller,T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/T9 r9calloc(se_dump_stack*caller,T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/void r9clear(se_dump_stack*caller,T9 C,T2 a1,T2 a2);
/*STRING*/T2 r7to_integer(se_dump_stack*caller,T7* C);
/*STRING*/T6 r7is_equal(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T6 r7is_default(se_dump_stack*caller,T7* C);
/*STRING*/T2 r7count(se_dump_stack*caller,T7* C);
/*STRING*/T2 r7upper(se_dump_stack*caller,T7* C);
/*STRING*/T3 r7last(se_dump_stack*caller,T7* C);
/*STRING*/void r7swap(se_dump_stack*caller,T7* C,T2 a1,T2 a2);
/*STRING*/T6 r7valid_index(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/T6 r7is_empty(se_dump_stack*caller,T7* C);
/*STRING*/T3 r7item(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/void r7copy(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T0* r7substring(se_dump_stack*caller,T7* C,T2 a1,T2 a2);
/*STRING*/T0* r7default(se_dump_stack*caller,T7* C);
/*STRING*/T2 r7reverse_index_of(se_dump_stack*caller,T7* C,T3 a1,T2 a2);
/*STRING*/void r7put(se_dump_stack*caller,T7* C,T3 a1,T2 a2);
/*STRING*/T0* r7twin(se_dump_stack*caller,T7* C);
/*STRING*/T0* r7_ix_43(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/void r7append(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T6 r7has_substring(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T2 r7index_of(se_dump_stack*caller,T7* C,T3 a1,T2 a2);
/*STRING*/T6 r7same_dynamic_type(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/void r7set_count(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/T6 r7is_integer(se_dump_stack*caller,T7* C);
/*STRING*/void r7clear_count(se_dump_stack*caller,T7* C);
/*STRING*/T6 r7_ix_60(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/void r7extend(se_dump_stack*caller,T7* C,T3 a1);
/*STRING*/void r7remove_last(se_dump_stack*caller,T7* C);
/*STRING*/void r7make(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/T2 r7hash_code(se_dump_stack*caller,T7* C);
/*STRING*/T6 r7has(se_dump_stack*caller,T7* C,T3 a1);
/*STRING*/void r7to_upper(se_dump_stack*caller,T7* C);
/*STRING*/void r7add_last(se_dump_stack*caller,T7* C,T3 a1);
/*STRING*/void r7resize(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/T2 r7substring_index(se_dump_stack*caller,T7* C,T0* a1,T2 a2);
/*STRING*/void r7ensure_capacity(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/T6 r7same_as(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T8 r7to_external(se_dump_stack*caller,T7* C);
/*STRING*/T2 r7last_index_of(se_dump_stack*caller,T7* C,T3 a1);
extern se_frame_descriptor se_ifd7;
T7*se_i7(se_dump_stack*caller,T7*C);
extern T0*ms62_117797837;
T0*se_ms(int c,char*e);
T0*se_string(char*e);
void se_msi1(void);
void manifest_string_mark1(void);
void once_function_mark(void);
void gc_start(void);
extern na_env na_env185;
extern na_env na_env184;
extern na_env na_env182;
extern na_env na_env181;
extern na_env na_env180;
extern na_env na_env183;
extern na_env na_env179;
extern na_env na_env178;
typedef struct B48 gc48;
struct B48{T48 object;union {void*flag;gc48*next;} header;};
extern gc48*store48;
extern int store_left48;
extern fsoc*store_chunk48;
extern gc48*gc_free48;
typedef struct B49 gc49;
struct B49{T49 object;union {void*flag;gc49*next;} header;};
extern gc49*store49;
extern int store_left49;
extern fsoc*store_chunk49;
extern gc49*gc_free49;
typedef struct B177 gc177;
struct B177{T177 object;union {void*flag;gc177*next;} header;};
extern gc177*store177;
extern int store_left177;
extern fsoc*store_chunk177;
extern gc177*gc_free177;
typedef struct B64 gc64;
struct B64{T64 object;union {void*flag;gc64*next;} header;};
extern gc64*store64;
extern int store_left64;
extern fsoc*store_chunk64;
extern gc64*gc_free64;
typedef struct B176 gc176;
struct B176{T176 object;union {void*flag;gc176*next;} header;};
extern gc176*store176;
extern int store_left176;
extern fsoc*store_chunk176;
extern gc176*gc_free176;
typedef struct B60 gc60;
struct B60{T60 object;union {void*flag;gc60*next;} header;};
extern gc60*store60;
extern int store_left60;
extern fsoc*store_chunk60;
extern gc60*gc_free60;
typedef struct B174 gc174;
struct B174{T174 object;union {void*flag;gc174*next;} header;};
extern gc174*store174;
extern int store_left174;
extern fsoc*store_chunk174;
extern gc174*gc_free174;
typedef struct B56 gc56;
struct B56{T56 object;union {void*flag;gc56*next;} header;};
extern gc56*store56;
extern int store_left56;
extern fsoc*store_chunk56;
extern gc56*gc_free56;
typedef struct B173 gc173;
struct B173{T173 object;union {void*flag;gc173*next;} header;};
extern gc173*store173;
extern int store_left173;
extern fsoc*store_chunk173;
extern gc173*gc_free173;
typedef struct B59 gc59;
struct B59{T59 object;union {void*flag;gc59*next;} header;};
extern gc59*store59;
extern int store_left59;
extern fsoc*store_chunk59;
extern gc59*gc_free59;
typedef struct B172 gc172;
struct B172{T172 object;union {void*flag;gc172*next;} header;};
extern gc172*store172;
extern int store_left172;
extern fsoc*store_chunk172;
extern gc172*gc_free172;
typedef struct B50 gc50;
struct B50{T50 object;union {void*flag;gc50*next;} header;};
extern gc50*store50;
extern int store_left50;
extern fsoc*store_chunk50;
extern gc50*gc_free50;
typedef struct B175 gc175;
struct B175{T175 object;union {void*flag;gc175*next;} header;};
extern gc175*store175;
extern int store_left175;
extern fsoc*store_chunk175;
extern gc175*gc_free175;
typedef struct B58 gc58;
struct B58{T58 object;union {void*flag;gc58*next;} header;};
extern gc58*store58;
extern int store_left58;
extern fsoc*store_chunk58;
extern gc58*gc_free58;
typedef struct B171 gc171;
struct B171{T171 object;union {void*flag;gc171*next;} header;};
extern gc171*store171;
extern int store_left171;
extern fsoc*store_chunk171;
extern gc171*gc_free171;
typedef struct B170 gc170;
struct B170{T170 object;union {void*flag;gc170*next;} header;};
extern gc170*store170;
extern int store_left170;
extern fsoc*store_chunk170;
extern gc170*gc_free170;
typedef struct B61 gc61;
struct B61{T61 object;union {void*flag;gc61*next;} header;};
extern gc61*store61;
extern int store_left61;
extern fsoc*store_chunk61;
extern gc61*gc_free61;
typedef struct B41 gc41;
struct B41{T41 object;union {void*flag;gc41*next;} header;};
extern gc41*store41;
extern int store_left41;
extern fsoc*store_chunk41;
extern gc41*gc_free41;
typedef struct B25 gc25;
struct B25{T25 object;union {void*flag;gc25*next;} header;};
extern gc25*store25;
extern int store_left25;
extern fsoc*store_chunk25;
extern gc25*gc_free25;
extern na_env na_env9;
typedef struct B7 gc7;
struct B7{T7 object;union {void*flag;gc7*next;} header;};
extern gc7*store7;
extern int store_left7;
extern fsoc*store_chunk7;
extern gc7*gc_free7;
void gc_mark185(T185 o);
T185 new185(unsigned int size);
void gc_mark184(T184 o);
T184 new184(unsigned int size);
void gc_mark182(T182 o);
T182 new182(unsigned int size);
void gc_mark181(T181 o);
T181 new181(unsigned int size);
void gc_mark180(T180 o);
T180 new180(unsigned int size);
void gc_mark183(T183 o);
T183 new183(unsigned int size);
void gc_mark179(T179 o);
T179 new179(unsigned int size);
void gc_mark178(T178 o);
T178 new178(unsigned int size);
void gc_sweep48(fsoc*c);
void gc_mark48(T48*o);
void gc_align_mark48(fsoc*c,gc48*p);
extern fsoc H48;
T48*new48(void);
void gc_sweep49(fsoc*c);
void gc_mark49(T49*o);
void gc_align_mark49(fsoc*c,gc49*p);
extern fsoc H49;
T49*new49(void);
void gc_sweep177(fsoc*c);
void gc_mark177(T177*o);
void gc_align_mark177(fsoc*c,gc177*p);
extern fsoc H177;
T177*new177(void);
void gc_sweep64(fsoc*c);
void gc_mark64(T64*o);
void gc_align_mark64(fsoc*c,gc64*p);
extern fsoc H64;
T64*new64(void);
void gc_sweep176(fsoc*c);
void gc_mark176(T176*o);
void gc_align_mark176(fsoc*c,gc176*p);
extern fsoc H176;
T176*new176(void);
void gc_sweep60(fsoc*c);
void gc_mark60(T60*o);
void gc_align_mark60(fsoc*c,gc60*p);
extern fsoc H60;
T60*new60(void);
void gc_sweep174(fsoc*c);
void gc_mark174(T174*o);
void gc_align_mark174(fsoc*c,gc174*p);
extern fsoc H174;
T174*new174(void);
void gc_sweep56(fsoc*c);
void gc_mark56(T56*o);
void gc_align_mark56(fsoc*c,gc56*p);
extern fsoc H56;
T56*new56(void);
void gc_sweep173(fsoc*c);
void gc_mark173(T173*o);
void gc_align_mark173(fsoc*c,gc173*p);
extern fsoc H173;
T173*new173(void);
void gc_sweep59(fsoc*c);
void gc_mark59(T59*o);
void gc_align_mark59(fsoc*c,gc59*p);
extern fsoc H59;
T59*new59(void);
void gc_sweep172(fsoc*c);
void gc_mark172(T172*o);
void gc_align_mark172(fsoc*c,gc172*p);
extern fsoc H172;
T172*new172(void);
void gc_sweep50(fsoc*c);
void gc_mark50(T50*o);
void gc_align_mark50(fsoc*c,gc50*p);
extern fsoc H50;
T50*new50(void);
void gc_sweep175(fsoc*c);
void gc_mark175(T175*o);
void gc_align_mark175(fsoc*c,gc175*p);
extern fsoc H175;
T175*new175(void);
void gc_sweep58(fsoc*c);
void gc_mark58(T58*o);
void gc_align_mark58(fsoc*c,gc58*p);
extern fsoc H58;
T58*new58(void);
void gc_sweep171(fsoc*c);
void gc_mark171(T171*o);
void gc_align_mark171(fsoc*c,gc171*p);
extern fsoc H171;
T171*new171(void);
void gc_sweep170(fsoc*c);
void gc_mark170(T170*o);
void gc_align_mark170(fsoc*c,gc170*p);
extern fsoc H170;
T170*new170(void);
void gc_sweep61(fsoc*c);
void gc_mark61(T61*o);
void gc_align_mark61(fsoc*c,gc61*p);
extern fsoc H61;
T61*new61(void);
void gc_sweep41(fsoc*c);
void gc_mark41(T41*o);
void gc_align_mark41(fsoc*c,gc41*p);
extern fsoc H41;
T41*new41(void);
void gc_sweep25(fsoc*c);
void gc_mark25(T25*o);
void gc_align_mark25(fsoc*c,gc25*p);
extern fsoc H25;
T25*new25(void);
void gc_mark9(T9 o);
T9 new9(unsigned int size);
void gc_sweep7(fsoc*c);
void gc_mark7(T7*o);
void gc_align_mark7(fsoc*c,gc7*p);
extern fsoc H7;
T7*new7(void);
void Xgc_mark170(T0*o);
void Xgc_mark51(T0*o);
extern T25*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 186
extern T7*g[];
extern T7*t[];
extern char*p[];
extern void(*se_prinT[186])(FILE*,void*);
extern int se_strucT[];
void se_atexit(void);
void initialize_eiffel_runtime(int argc,char*argv[]);
int main(int argc,char*argv[]);

#ifdef __cplusplus
}
#endif
